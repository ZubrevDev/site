<?php return array (
  'preserve_keys' => true,
  'update_object' => false,
  'unique_key' => 
  array (
    0 => 'category',
  ),
  'related_objects' => 
  array (
    'Snippets' => 
    array (
      '73b8c6561bc558237660a714d2e7fb26' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":1,"source":0,"property_preprocess":0,"name":"Query","description":"A generic utility\\/interface used for querying any MODX database collection.","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\n * @name Query\\n * @description A generic utility\\/interface used for querying any MODX database collection.\\n *\\n * USAGE\\n *\\n *  [[Query? &_classname=`modResource` &template=`3`]]\\n *\\n * No Results - rely on MODX output filters.\\n *\\n *  [[Query:empty=`No results found`? &_classname=`modUser` &_tpl=`SingleUser`]]\\n *\\n *\\n * Copyright 2014 by Everett Griffiths <everett@craftsmancoding.com>\\n * Created on 05-12-2013\\n * \\n * Control Parameters\\n * ------------------\\n * All \\"control\\" parameters begin with an underscore. They affect the functionality or formatting of the output.\\n *\\n *  @param string _classname classname of the object collection you are querying. [default=modResource]\\n *  @param string _pkg colon-separated string defining the arguments for addPackage() - package_name, model_path, and optionally table_prefix e.g. `tiles:[[++core_path]]components\\/tiles\\/model\\/:tiles_` or if only the package name is supplied, the path is assumed to be \\"[[++core_path]]components\\/$package_name\\/model\\/\\"\\n *  @param string _tpl chunk or formatting-string to format each record in the collection\\n *  @param string _tplOuter chunk or formatting-string to wrap the result set. Requires the [[+content]] placeholder.\\n *  @param string _view oldschool php file to format the output, see the views folder.\\n *      Some samples are provided, e.g. \'table\', \'json\'. If _tpl\\n *      and _tplOuter are provided, the _view parameter is ignored.  Default: table.php\\n *  @param integer _limit limits the number of results returned, also sets the results shown per page.\\n *  @param integer _offset offsets the first record returned, e.g. for pagination.\\n *  @param string _sortby column to sort by\\n *  @param string _sortdir sort direction. Usually ASC or DESC, but may also contain complex sorting rules.\\n *  @param string _sql used to issue a raw SQL query.\\n *  @param string _style one of Pagination\'s styles (see https:\\/\\/github.com\\/craftsmancoding\\/pagination)\\n *  @param string _graph triggers a getCollectionGraph.\\n *  @param string _select controls which columns to select for a getCollection. Ignored when _graph is set. Default: *\\n *  @param string _config sets a pagination formatting pallette, e.g. \\"default\\". Corresponding file must exist inside the config directory, e.g. \\"default.config.php\\"\\n *  @param integer _log_level overrides the MODX log_level system setting. Defaults to System Setting.\\n *  @param boolean _debug triggers debugging information to be set.\\n *\\n * Filter Parameters\\n * ----------------\\n * All other parameters act as query filters and they depend on the collection being queried.\\n * Any parameter that does not begin with an underscore is considered a filter parameter.\\n *\\n *\\n * Input Operators\\n * ---------------\\n *  Apply these to the end of any parameter name with a colon, e.g. &firstname:LIKE=`Sue`\\n *  E          =   equals\\n *  NE         !=  not equal\\n *  GT         >   greater than\\n *  LT         <   less than\\n *  GTE        >=  greater than or equal to\\n *  LTE        <=  less than or equal to\\n *  LIKE       LIKE -- Query will automatically quote the input value as \'%value%\'\\n *  NOT_LIKE   NOT LIKE\\n *  NOT_IN     NOT IN\\n *  IN         IN\\n *  STARTS_WITH behaves like \\"LIKE\\", but quotes the value as \'value%\'\\n *  ENDS_WITH behaves like \\"LIKE\\", but quotes the value as \'%value\' \\n *\\n * \\n * Input Value Modifiers\\n * ---------------\\n * Inspired by MODX\'s Output Filters (see http:\\/\\/goo.gl\\/bSzfwi), the Query Snippet supports \\n * dynamic inputs via its own \\"value modifiers\\" that mimic the syntax used by MODX for its output \\n * filters (aka \\"output modifiers).  This is useful for building search forms or enabling pagination.  \\n * For example, you can change the &_sortby argument dynamically by setting a URL parameter, then you \\n * can adjust your Query snippet call to read the \\"sortby\\" $_GET variable:\\n *\\n *      [[!Query? &_sortby=`sortby:get`]]\\n *\\n * There are 3 value modifiers included:\\n *\\n *  get : causes the named value to read from the $_GET array.  $options = default value.\\n *  post : causes the named value to read from the $_POST array. $options = default value. \\n *  decode : runs json_decode on the input. Useful if you need to pass an array as an argument.\\n *\\n * You can also supply your own Snippet names to be used as value modifiers instead of relying on the included get, post\\n * and decode. Your custom value modifiers should accept the following inputs\\n *  $input : the value sent to the snippet.  E.g. in &_sortby=`xyz:customvaluemodifier`, the $input is \\"xyz\\"\\n *  $options : any extra option. E.g. &_sortby=`xyz:customvaluemodifier=123`, the $options is \\"123\\". These may be quoted any way you prefer.\\n *\\n * WARNING: use value modifiers with extreme caution! Query does not perform any data sanitization, so these\\n * could be exploited via SQL injection if you exposed a value that should not be exposed (like &_sql).\\n * \\n * \\n *\\n * Variables\\n * ---------\\n * @var $modx modX\\n * @var $scriptProperties array\\n *\\n * $modx->getAggregates() and getComposites() or you can access the $obj->_aggregates and $obj->_composites directly\\n * $graph = $xpdo->getGraph(\'Classname\', 1)\\n * print_r($modx->classMap) -- lets you trace out all avail. objects\\n * @package query\\n *\\/\\n\\n\\/\\/ Caching needs to encapsulate changes in GET and POST since input filters mean that the $scriptProperties may not change\\n$cache_opts = array(xPDO::OPT_CACHE_KEY => \'query\');\\n$lifetime = 0;\\n$fingerprint = md5(\'query\'.serialize(array($scriptProperties,$_POST,$_GET)));\\nif ($results = $modx->cacheManager->get($fingerprint, $cache_opts))\\n{\\n    $modx->setPlaceholder(\'page_count\',$results[\'page_count\']);\\n    $modx->setPlaceholder(\'results\',$results[\'results\']);\\n    $modx->setPlaceholder(\'pagination_links\',$results[\'pagination_links\']);\\n\\n    return $results[\'results\'];\\n}\\n\\n$core_path = $modx->getOption(\'query.core_path\',\'\',MODX_CORE_PATH.\'components\\/query\\/\');\\nrequire_once $core_path .\'vendor\\/autoload.php\';\\n\\/\\/ TODO: Restricted properties (cannot use the get: and post: convenience methods)\\n\\/\\/ Process the raw $scriptProperties into filters and control_params.\\n\\/\\/ FYI: We need to translate some stuff here (e.g. \'<=\' becomes \'LTE\') due to limitations in the Snippet Syntax.\\n\\/\\/ See http:\\/\\/rtfm.modx.com\\/xpdo\\/2.x\\/class-reference\\/xpdoquery\\/xpdoquery.where\\n$control_params = array();\\n\\/\\/$scriptProperties; \\/\\/ not a reference!\\n$filters = array();\\n\\/\\/ We track which placeholders we set\\n$placeholder_keys = array();\\n$page_count = 1; \\/\\/ default is one page\\n\\nforeach ($scriptProperties as $k => $v) {\\n\\n    \\/\\/ Dynamically modify values via our \\"input filters\\"\\n    $filter = null;\\n    $raw_k = $k;\\n    \\/\\/ $v might be something like `year:get=2012`\\n    preg_match(\\"\\/^(.*):((\\\\w+)(=[\'`\\\\\\"]?([^\'`\\\\\\"]*)[\'`\\\\\\"]?)?)$\\/i\\", $v, $matches);\\n    if ($matches) {\\n        $filter = (isset($matches[3]))? $matches[3] : \'\';\\n        $x = (isset($matches[1]))? $matches[1] : \'\'; \\/\\/ whatever\'s to the left of the filter, e.g. \'year\'\\n        $y = (isset($matches[4]))? $matches[4] : \'\'; \\/\\/ any option, e.g. =\\"2012\\"\\n\\n        \\/\\/ Input Modifiers\\n        \\/\\/ Don\'t use getOption here because it will read db config data if there is no $_POST data!\\n        if (strtolower($filter) == \'get\') {\\n            $v = (isset($_GET[$x]))? $_GET[$x]: ltrim($y,\'=\');\\n        }\\n        elseif (strtolower($filter) == \'post\') {\\n            $v = (isset($_POST[$x]))? $_POST[$x]: ltrim($y,\'=\');\\n        }\\n        elseif (strtolower($filter) == \'decode\') {\\n            $v = json_decode($matches[1]);\\n        }\\n        else {\\n            $v = $modx->runSnippet($filter,array(\'input\'=>$x,\'options\'=>$y));\\n        }\\n    }\\n\\n    \\/\\/ All control_params begin with an underscore\\n    if ($k[0] == \'_\') {\\n        $control_params[$k] = $v;\\n        unset($scriptProperties[$k]);\\n        continue;\\n    }\\n\\n    \\/\\/ Placeholders are used for debugging, raw SQL, and ???\\n    $placeholder_keys[] = \'query.\'.$raw_k;\\n    $modx->toPlaceholder($raw_k,htmlspecialchars($v),\'query\');\\n\\n    \\/\\/ Modify the keys (i.e. translate the syntax to xPDO)\\n    if (strtolower(substr($k,-2))==\':e\') {\\n        $k = substr($k,0,-2).\':=\';\\n    }\\n    elseif (strtolower(substr($k,-3))==\':ne\') {\\n        $k = substr($k,0,-3).\':!=\';\\n    }\\n    elseif (strtolower(substr($k,-3))==\':gt\') {\\n        $k = substr($k,0,-3).\':>\';\\n    }\\n    elseif (strtolower(substr($k,-4))==\':gte\') {\\n        $k = substr($k,0,-4).\':>=\';\\n    }\\n    elseif (strtolower(substr($k,-3))==\':lt\') {\\n        $k = substr($k,0,-3).\':<\';\\n    }\\n    elseif (strtolower(substr($k,-4))==\':lte\') {\\n        $k = substr($k,0,-4).\':<=\';\\n    }\\n    elseif (strtolower(substr($k,-5))==\':like\') {\\n        $v = \'%\'.trim($v,\'%\').\'%\';\\n    }\\n    elseif (strtolower(substr($k,-9))==\':not_like\') {\\n        $k = substr($k,0,-9).\':NOT LIKE\';\\n        $v = \'%\'.trim($v,\'%\').\'%\';\\n    }\\n    elseif (strtolower(substr($k,-3))==\':in\') {\\n        $v = (!is_array($v))? explode(\',\',$v):$v;\\n        $v = array_map(\'trim\', $v);\\n    }\\n    elseif (strtolower(substr($k,-7))==\':not_in\') {\\n        $k = substr($k,0,-7).\':NOT IN\';\\n        $v = (!is_array($v))? explode(\',\',$v):$v;\\n        $v = array_map(\'trim\', $v);\\n    }\\n    elseif (strtolower(substr($k,-12))==\':starts_with\') {\\n        $k = substr($k,0,-12).\':LIKE\';\\n        $v = trim($v,\'%\').\'%\';\\n    }\\n    elseif (strtolower(substr($k,-10))==\':ends_with\') {\\n        $k = substr($k,0,-10).\':LIKE\';\\n        $v = \'%\'.trim($v,\'%\');\\n    }\\n    \\n    if (strtolower($v) == \'null\') {\\n        $v = null;\\n    }\\n    \\n    \\/\\/ Manually set an operator\\n    if (isset($scriptProperties[\'_op_\'.$k])) {\\n        $k = $k.\':\'.ltrim($scriptProperties[\'_op_\'.$k],\':\');\\n    }\\n    unset($scriptProperties[\'_op_\'.$k]);\\n    $filters[$k] = $v;\\n}\\n\\n\\/\\/ Read the control arguments\\n$classname = $modx->getOption(\'_classname\', $control_params,\'modResource\');\\n$pkg = $modx->getOption(\'_pkg\', $control_params);\\n$tpl = $modx->getOption(\'_tpl\', $control_params);\\n$tplOuter = $modx->getOption(\'_tplOuter\', $control_params);\\n$view = $modx->getOption(\'_view\', $control_params,\'table\');\\n$limit = (int) $modx->getOption(\'_limit\', $control_params);\\n$sortby = $modx->getOption(\'_sortby\', $control_params);\\n$sortdir = $modx->getOption(\'_sortdir\', $control_params,\'ASC\'); \\n$page = (int) $modx->getOption(\'_page\', $control_params);\\n$offset = (int) $modx->getOption(\'_offset\', $control_params);\\n$sql = $modx->getOption(\'_sql\', $control_params);\\n$style = $modx->getOption(\'_style\', $control_params, \'default\');\\n$graph = $modx->getOption(\'_graph\', $control_params);\\n$select = $modx->getOption(\'_select\', $control_params,\'*\');\\n$log_level = (int) $modx->getOption(\'_log_level\', $control_params,$modx->getOption(\'log_level\'));\\n$config = basename($modx->getOption(\'_config\', $control_params,\'default\'),\'.config.php\');\\n$debug = (int) $modx->getOption(\'_debug\', $control_params);\\n\\n$old_log_level = $modx->setLogLevel($log_level);\\n\\n\\/\\/ Load up any custom packages\\nif ($pkg) {\\n    $parts = explode(\':\',$pkg);\\n    if (isset($parts[2])) {\\n        $modx->addPackage($parts[0],$parts[1],$parts[2]);     \\n    }\\n    elseif(isset($parts[1])) {\\n        $modx->addPackage($parts[0],$parts[1]);\\n    }\\n    else {\\n        $modx->addPackage($parts[0],MODX_CORE_PATH.\'components\\/\'.$parts[0].\'\\/model\\/\');\\n    }\\n}\\n\\n$data = array();\\n$record_count = 0;\\n\\/\\/ Run raw sql?\\nif ($sql) {\\n    \\/\\/ include SQL_CALC_FOUND_ROWS in your query\\n    if ($limit) {\\n        $sql .= \' LIMIT \'.$limit;\\n        if ($offset) {\\n            $sql .= \' OFFSET \'.$offset;    \\n        }\\n    }\\n    \\/\\/ Quote any placeholders in case they are used in the query\\n    $ph = array();\\n    foreach ($placeholder_keys as $k) {\\n        $ph[$k] = $modx->quote($modx->getPlaceholder($k));\\n        $sql = str_replace(\'[[+\'.$k.\']]\', $ph[$k], $sql);\\n    }\\n    if ($debug) {\\n        return \'<div><h2><code>Query<\\/code> Snippet Debug<\\/h2><h3>Raw SQL<\\/h3><textarea rows=\\"10\\" cols=\\"60\\">\'.$sql.\'<\\/textarea>\\n            <h3>Placeholders<\\/h3>\\n            <textarea rows=\\"10\\" cols=\\"60\\">\'.print_r($ph,true).\'<\\/textarea>\\n            <h3>POST<\\/h3>\\n            <textarea rows=\\"10\\" cols=\\"60\\">\'.print_r($_POST,true).\'<\\/textarea>\\n        <\\/div>\';\\n    }\\n\\n    $result = $modx->query($sql);\\n    $data = $result->fetchAll(PDO::FETCH_ASSOC);\\n\\n    $result2 = $modx->query(\'SELECT FOUND_ROWS() as total_pages\');\\n    $data2 = $result2->fetch(PDO::FETCH_ASSOC);\\n    \\/\\/return \'<pre>\'.print_r($data2,true).\'<\\/pre>\';\\n    $record_count = $data2[\'total_pages\'];\\n}\\nelse {    \\n    $cols = array();\\n    if ($select != \'*\') {\\n        $cols = explode(\',\',$select);\\n        $cols = array_map(\'trim\', $cols);\\n    }\\n\\n    $criteria = $modx->newQuery($classname);\\n    \\/\\/ Graphing potentially needs *all* fields to function, so forcefully restricting it via \\"select\\" it is not rec\'d\\n    if (!$graph) {\\n        $criteria->select($select);\\n    }\\n    $criteria->where($filters);\\n    $record_count = $modx->getCount($classname,$criteria);\\n    $criteria->limit($limit, $offset); \\n    if ($sortby) {\\n        $criteria->sortby($sortby,$sortdir);\\n    }\\n\\n    if ($graph) {\\n        $results = $modx->getCollectionGraph($classname,$graph,$criteria);\\n\\n        \\/\\/$criteria->bindGraph($graph);\\n        \\/\\/return print_r($results,true);\\n    }\\n    else {\\n        $results = $modx->getCollection($classname,$criteria);\\n    }\\n    \\/\\/ TODO: More info displayed here\\n    if ($debug) {\\n        $criteria->prepare();\\n        return \'<div><h2><code>Query<\\/code> Snippet Debug<\\/h2><h3>Raw SQL<\\/h3><textarea rows=\\"10\\" cols=\\"60\\">\'.$criteria->toSQL().\'<\\/textarea>\\n            <h3>POST<\\/h3>\\n            <textarea rows=\\"10\\" cols=\\"60\\">\'.print_r($_POST,true).\'<\\/textarea>\\n            <h3>Control Parameters<\\/h3>\\n            <textarea rows=\\"10\\" cols=\\"60\\">\'.print_r($control_params,true).\'<\\/textarea>\\n            <h3>Filters<\\/h3>\\n            <textarea rows=\\"10\\" cols=\\"60\\">\'.print_r($filters,true).\'<\\/textarea>\\n        <\\/div>\';\\n    }\\n\\n    foreach ($results as $r) {\\n        \\/\\/ Cheap trick to flatten the hierarchy using toPlaceholders\\n        if ($graph) {\\n            $keys = $modx->toPlaceholders($r->toArray(\'\',false,true,$graph),\'tmp\'); \\/\\/ without period\\n        }\\n        else {\\n            $keys = $modx->toPlaceholders($r->toArray(),\'tmp\'); \\/\\/ without period\\n        }\\n\\n        $this_row = array();\\n        \\/\\/ Cols are set only when $graph && $select\\n        if ($cols) {\\n            foreach ($cols as $k) {\\n                \\/\\/ $k seems to come out clean when $select is used\\n                $this_row[$k] = $modx->getPlaceholder(\'tmp.\'.$k); \\/\\/ with period\\n            }\\n        }\\n        else {\\n            foreach ($keys[\'keys\'] as $k) {\\n                $clean_k = substr($k,4); \\/\\/ remove the tmp.\\n                $this_row[$clean_k] = $modx->getPlaceholder($k); \\n            }\\n        }\\n        $data[] = $this_row;\\n    }\\n\\n}\\n\\nif (empty($data)) {\\n    $modx->log(xPDO::LOG_LEVEL_DEBUG,\'[Query] No output.\');\\n    return \'\';\\n}\\n\\n$out = \'\';\\n$pagination_links = \'\';\\n\\n\\/\\/ Pagination\\nif ($limit && $record_count > $limit) {\\n    \\n    \\/\\/Pagination\\\\Pager::style($style);\\n    $pagination_links = Pagination\\\\Pager::links($record_count, $offset, $limit)\\n        ->setBaseUrl($modx->makeUrl($modx->resource->get(\'id\'),\'\',\'\',\'abs\'))\\n        ->style($style);\\n    $page_count = ceil(record_count \\/ $limit);\\n}\\n\\n\\/\\/ Default formatting (via a PHP view)\\nif (!$tpl && !$tplOuter) {\\n    $view_file = $core_path.\'views\\/\'.basename($view,\'.php\').\'.php\';    \\n    if (!file_exists($view_file)) {\\n        $view_file = $view;\\n        if (!file_exists($view_file)) {\\n            $modx->log(xPDO::LOG_LEVEL_ERROR,\'[Query] The view file \'.$view_file.\' does not exist.\');\\n            return \'The view file \'.htmlspecialchars($view_file).\' does not exist.\';\\n        }\\n    }\\n    ob_start();\\n    include $view_file;\\n    $out = ob_get_contents();\\n    ob_end_clean();\\n}\\nelseif($tpl) {\\n\\n    $use_tmp_chunk = false;\\n    if (!$innerChunk = $modx->getObject(\'modChunk\', array(\'name\' => $tpl))) {\\n        $use_tmp_chunk = true; \\/\\/ No chunk was passed... a formatting string was passed instead.\\n    }\\n    \\n    foreach ($data as $r) {\\n        if (is_object($r)) $r = $r->toArray(\'\',false,false,true); \\/\\/ Handle xPDO objects\\n        \\/\\/ Use a temporary Chunk when dealing with raw formatting strings\\n        if ($use_tmp_chunk) {\\n            $uniqid = uniqid();\\n            $innerChunk = $modx->newObject(\'modChunk\', array(\'name\' => \\"{tmp-inner}-{$uniqid}\\"));\\n            $innerChunk->setCacheable(false);    \\n            $out .= $innerChunk->process($r, $tpl);\\n        }\\n        \\/\\/ Use getChunk when a chunk name was passed\\n        else {\\n            $out .= $modx->getChunk($tpl, $r);\\n        }\\n    }\\n}\\n\\nif ($tplOuter) {\\n    $props = array(\'content\'=>$out);\\n    \\/\\/ Formatting String\\n    if (!$outerChunk = $modx->getObject(\'modChunk\', array(\'name\' => $tplOuter))) {  \\n        $uniqid = uniqid();\\n        $outerChunk = $modx->newObject(\'modChunk\', array(\'name\' => \\"{tmp-outer}-{$uniqid}\\"));\\n        $outerChunk->setCacheable(false);    \\n        $out = $outerChunk->process($props, $tplOuter);        \\n    }\\n    \\/\\/ Chunk Name\\n    else {\\n        $out = $modx->getChunk($tplOuter, $props);\\n    }\\n}\\n\\n\\/\\/ Set placeholders\\n$modx->setPlaceholder(\'page_count\',$page_count);\\n$modx->setPlaceholder(\'results\',$out);\\n$modx->setPlaceholder(\'pagination_links\',$pagination_links);\\n$modx->setLogLevel($old_log_level);\\n\\n$results = array(\\n    \'page_count\' => $page_count,\\n    \'results\' => $out,\\n    \'pagination_links\' => $pagination_links,\\n);\\n\\n\\/\\/ Cache the lookup\\n$modx->cacheManager->set($fingerprint, $results, $lifetime, $cache_opts);\\n\\nreturn $out;","locked":0,"properties":"a:16:{s:10:\\"_classname\\";a:7:{s:4:\\"name\\";s:10:\\"_classname\\";s:4:\\"desc\\";s:52:\\"classname of the object collection you are querying.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:11:\\"modResource\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:4:\\"_pkg\\";a:7:{s:4:\\"name\\";s:4:\\"_pkg\\";s:4:\\"desc\\";s:293:\\"colon-separated string defining the arguments for addPackage() - package_name, model_path, and optionally table_prefix e.g. `tiles:[[++core_path]]components\\/tiles\\/model\\/:tiles_` or if only the package name is supplied, the path is assumed to be \\"[[++core_path]]components\\/$package_name\\/model\\/\\"\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:4:\\"_tpl\\";a:7:{s:4:\\"name\\";s:4:\\"_tpl\\";s:4:\\"desc\\";s:66:\\"chunk or formatting-string to format each record in the collection\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:9:\\"_tplOuter\\";a:7:{s:4:\\"name\\";s:9:\\"_tplOuter\\";s:4:\\"desc\\";s:89:\\"chunk or formatting-string to wrap the result set. Requires the [[+content]] placeholder.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:5:\\"_view\\";a:7:{s:4:\\"name\\";s:5:\\"_view\\";s:4:\\"desc\\";s:62:\\"oldschool php file to format the output, see the views folder.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:6:\\"_limit\\";a:7:{s:4:\\"name\\";s:6:\\"_limit\\";s:4:\\"desc\\";s:76:\\"limits the number of results returned, also sets the results shown per page.\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:7:\\"_offset\\";a:7:{s:4:\\"name\\";s:7:\\"_offset\\";s:4:\\"desc\\";s:55:\\"offsets the first record returned, e.g. for pagination.\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:7:\\"_sortby\\";a:7:{s:4:\\"name\\";s:7:\\"_sortby\\";s:4:\\"desc\\";s:17:\\"column to sort by\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:8:\\"_sortdir\\";a:7:{s:4:\\"name\\";s:8:\\"_sortdir\\";s:4:\\"desc\\";s:80:\\"sort direction. Usually ASC or DESC, but may also contain complex sorting rules.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:4:\\"_sql\\";a:7:{s:4:\\"name\\";s:4:\\"_sql\\";s:4:\\"desc\\";s:30:\\"used to issue a raw SQL query.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:6:\\"_style\\";a:7:{s:4:\\"name\\";s:6:\\"_style\\";s:4:\\"desc\\";s:78:\\"one of Pagination\'s styles (see https:\\/\\/github.com\\/craftsmancoding\\/pagination)\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:6:\\"_graph\\";a:7:{s:4:\\"name\\";s:6:\\"_graph\\";s:4:\\"desc\\";s:30:\\"triggers a getCollectionGraph.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:7:\\"_select\\";a:7:{s:4:\\"name\\";s:7:\\"_select\\";s:4:\\"desc\\";s:92:\\"controls which columns to select for a getCollection. Ignored when _graph is set. Default: *\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:7:\\"_config\\";a:7:{s:4:\\"name\\";s:7:\\"_config\\";s:4:\\"desc\\";s:139:\\"sets a pagination formatting pallette, e.g. \\"default\\". Corresponding file must exist inside the config directory, e.g. \\"default.config.php\\"\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:10:\\"_log_level\\";a:7:{s:4:\\"name\\";s:10:\\"_log_level\\";s:4:\\"desc\\";s:72:\\"overrides the MODX log_level system setting. Defaults to System Setting.\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:6:\\"_debug\\";a:7:{s:4:\\"name\\";s:6:\\"_debug\\";s:4:\\"desc\\";s:41:\\"triggers debugging information to be set.\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * @name Query\\n * @description A generic utility\\/interface used for querying any MODX database collection.\\n *\\n * USAGE\\n *\\n *  [[Query? &_classname=`modResource` &template=`3`]]\\n *\\n * No Results - rely on MODX output filters.\\n *\\n *  [[Query:empty=`No results found`? &_classname=`modUser` &_tpl=`SingleUser`]]\\n *\\n *\\n * Copyright 2014 by Everett Griffiths <everett@craftsmancoding.com>\\n * Created on 05-12-2013\\n * \\n * Control Parameters\\n * ------------------\\n * All \\"control\\" parameters begin with an underscore. They affect the functionality or formatting of the output.\\n *\\n *  @param string _classname classname of the object collection you are querying. [default=modResource]\\n *  @param string _pkg colon-separated string defining the arguments for addPackage() - package_name, model_path, and optionally table_prefix e.g. `tiles:[[++core_path]]components\\/tiles\\/model\\/:tiles_` or if only the package name is supplied, the path is assumed to be \\"[[++core_path]]components\\/$package_name\\/model\\/\\"\\n *  @param string _tpl chunk or formatting-string to format each record in the collection\\n *  @param string _tplOuter chunk or formatting-string to wrap the result set. Requires the [[+content]] placeholder.\\n *  @param string _view oldschool php file to format the output, see the views folder.\\n *      Some samples are provided, e.g. \'table\', \'json\'. If _tpl\\n *      and _tplOuter are provided, the _view parameter is ignored.  Default: table.php\\n *  @param integer _limit limits the number of results returned, also sets the results shown per page.\\n *  @param integer _offset offsets the first record returned, e.g. for pagination.\\n *  @param string _sortby column to sort by\\n *  @param string _sortdir sort direction. Usually ASC or DESC, but may also contain complex sorting rules.\\n *  @param string _sql used to issue a raw SQL query.\\n *  @param string _style one of Pagination\'s styles (see https:\\/\\/github.com\\/craftsmancoding\\/pagination)\\n *  @param string _graph triggers a getCollectionGraph.\\n *  @param string _select controls which columns to select for a getCollection. Ignored when _graph is set. Default: *\\n *  @param string _config sets a pagination formatting pallette, e.g. \\"default\\". Corresponding file must exist inside the config directory, e.g. \\"default.config.php\\"\\n *  @param integer _log_level overrides the MODX log_level system setting. Defaults to System Setting.\\n *  @param boolean _debug triggers debugging information to be set.\\n *\\n * Filter Parameters\\n * ----------------\\n * All other parameters act as query filters and they depend on the collection being queried.\\n * Any parameter that does not begin with an underscore is considered a filter parameter.\\n *\\n *\\n * Input Operators\\n * ---------------\\n *  Apply these to the end of any parameter name with a colon, e.g. &firstname:LIKE=`Sue`\\n *  E          =   equals\\n *  NE         !=  not equal\\n *  GT         >   greater than\\n *  LT         <   less than\\n *  GTE        >=  greater than or equal to\\n *  LTE        <=  less than or equal to\\n *  LIKE       LIKE -- Query will automatically quote the input value as \'%value%\'\\n *  NOT_LIKE   NOT LIKE\\n *  NOT_IN     NOT IN\\n *  IN         IN\\n *  STARTS_WITH behaves like \\"LIKE\\", but quotes the value as \'value%\'\\n *  ENDS_WITH behaves like \\"LIKE\\", but quotes the value as \'%value\' \\n *\\n * \\n * Input Value Modifiers\\n * ---------------\\n * Inspired by MODX\'s Output Filters (see http:\\/\\/goo.gl\\/bSzfwi), the Query Snippet supports \\n * dynamic inputs via its own \\"value modifiers\\" that mimic the syntax used by MODX for its output \\n * filters (aka \\"output modifiers).  This is useful for building search forms or enabling pagination.  \\n * For example, you can change the &_sortby argument dynamically by setting a URL parameter, then you \\n * can adjust your Query snippet call to read the \\"sortby\\" $_GET variable:\\n *\\n *      [[!Query? &_sortby=`sortby:get`]]\\n *\\n * There are 3 value modifiers included:\\n *\\n *  get : causes the named value to read from the $_GET array.  $options = default value.\\n *  post : causes the named value to read from the $_POST array. $options = default value. \\n *  decode : runs json_decode on the input. Useful if you need to pass an array as an argument.\\n *\\n * You can also supply your own Snippet names to be used as value modifiers instead of relying on the included get, post\\n * and decode. Your custom value modifiers should accept the following inputs\\n *  $input : the value sent to the snippet.  E.g. in &_sortby=`xyz:customvaluemodifier`, the $input is \\"xyz\\"\\n *  $options : any extra option. E.g. &_sortby=`xyz:customvaluemodifier=123`, the $options is \\"123\\". These may be quoted any way you prefer.\\n *\\n * WARNING: use value modifiers with extreme caution! Query does not perform any data sanitization, so these\\n * could be exploited via SQL injection if you exposed a value that should not be exposed (like &_sql).\\n * \\n * \\n *\\n * Variables\\n * ---------\\n * @var $modx modX\\n * @var $scriptProperties array\\n *\\n * $modx->getAggregates() and getComposites() or you can access the $obj->_aggregates and $obj->_composites directly\\n * $graph = $xpdo->getGraph(\'Classname\', 1)\\n * print_r($modx->classMap) -- lets you trace out all avail. objects\\n * @package query\\n *\\/\\n\\n\\/\\/ Caching needs to encapsulate changes in GET and POST since input filters mean that the $scriptProperties may not change\\n$cache_opts = array(xPDO::OPT_CACHE_KEY => \'query\');\\n$lifetime = 0;\\n$fingerprint = md5(\'query\'.serialize(array($scriptProperties,$_POST,$_GET)));\\nif ($results = $modx->cacheManager->get($fingerprint, $cache_opts))\\n{\\n    $modx->setPlaceholder(\'page_count\',$results[\'page_count\']);\\n    $modx->setPlaceholder(\'results\',$results[\'results\']);\\n    $modx->setPlaceholder(\'pagination_links\',$results[\'pagination_links\']);\\n\\n    return $results[\'results\'];\\n}\\n\\n$core_path = $modx->getOption(\'query.core_path\',\'\',MODX_CORE_PATH.\'components\\/query\\/\');\\nrequire_once $core_path .\'vendor\\/autoload.php\';\\n\\/\\/ TODO: Restricted properties (cannot use the get: and post: convenience methods)\\n\\/\\/ Process the raw $scriptProperties into filters and control_params.\\n\\/\\/ FYI: We need to translate some stuff here (e.g. \'<=\' becomes \'LTE\') due to limitations in the Snippet Syntax.\\n\\/\\/ See http:\\/\\/rtfm.modx.com\\/xpdo\\/2.x\\/class-reference\\/xpdoquery\\/xpdoquery.where\\n$control_params = array();\\n\\/\\/$scriptProperties; \\/\\/ not a reference!\\n$filters = array();\\n\\/\\/ We track which placeholders we set\\n$placeholder_keys = array();\\n$page_count = 1; \\/\\/ default is one page\\n\\nforeach ($scriptProperties as $k => $v) {\\n\\n    \\/\\/ Dynamically modify values via our \\"input filters\\"\\n    $filter = null;\\n    $raw_k = $k;\\n    \\/\\/ $v might be something like `year:get=2012`\\n    preg_match(\\"\\/^(.*):((\\\\w+)(=[\'`\\\\\\"]?([^\'`\\\\\\"]*)[\'`\\\\\\"]?)?)$\\/i\\", $v, $matches);\\n    if ($matches) {\\n        $filter = (isset($matches[3]))? $matches[3] : \'\';\\n        $x = (isset($matches[1]))? $matches[1] : \'\'; \\/\\/ whatever\'s to the left of the filter, e.g. \'year\'\\n        $y = (isset($matches[4]))? $matches[4] : \'\'; \\/\\/ any option, e.g. =\\"2012\\"\\n\\n        \\/\\/ Input Modifiers\\n        \\/\\/ Don\'t use getOption here because it will read db config data if there is no $_POST data!\\n        if (strtolower($filter) == \'get\') {\\n            $v = (isset($_GET[$x]))? $_GET[$x]: ltrim($y,\'=\');\\n        }\\n        elseif (strtolower($filter) == \'post\') {\\n            $v = (isset($_POST[$x]))? $_POST[$x]: ltrim($y,\'=\');\\n        }\\n        elseif (strtolower($filter) == \'decode\') {\\n            $v = json_decode($matches[1]);\\n        }\\n        else {\\n            $v = $modx->runSnippet($filter,array(\'input\'=>$x,\'options\'=>$y));\\n        }\\n    }\\n\\n    \\/\\/ All control_params begin with an underscore\\n    if ($k[0] == \'_\') {\\n        $control_params[$k] = $v;\\n        unset($scriptProperties[$k]);\\n        continue;\\n    }\\n\\n    \\/\\/ Placeholders are used for debugging, raw SQL, and ???\\n    $placeholder_keys[] = \'query.\'.$raw_k;\\n    $modx->toPlaceholder($raw_k,htmlspecialchars($v),\'query\');\\n\\n    \\/\\/ Modify the keys (i.e. translate the syntax to xPDO)\\n    if (strtolower(substr($k,-2))==\':e\') {\\n        $k = substr($k,0,-2).\':=\';\\n    }\\n    elseif (strtolower(substr($k,-3))==\':ne\') {\\n        $k = substr($k,0,-3).\':!=\';\\n    }\\n    elseif (strtolower(substr($k,-3))==\':gt\') {\\n        $k = substr($k,0,-3).\':>\';\\n    }\\n    elseif (strtolower(substr($k,-4))==\':gte\') {\\n        $k = substr($k,0,-4).\':>=\';\\n    }\\n    elseif (strtolower(substr($k,-3))==\':lt\') {\\n        $k = substr($k,0,-3).\':<\';\\n    }\\n    elseif (strtolower(substr($k,-4))==\':lte\') {\\n        $k = substr($k,0,-4).\':<=\';\\n    }\\n    elseif (strtolower(substr($k,-5))==\':like\') {\\n        $v = \'%\'.trim($v,\'%\').\'%\';\\n    }\\n    elseif (strtolower(substr($k,-9))==\':not_like\') {\\n        $k = substr($k,0,-9).\':NOT LIKE\';\\n        $v = \'%\'.trim($v,\'%\').\'%\';\\n    }\\n    elseif (strtolower(substr($k,-3))==\':in\') {\\n        $v = (!is_array($v))? explode(\',\',$v):$v;\\n        $v = array_map(\'trim\', $v);\\n    }\\n    elseif (strtolower(substr($k,-7))==\':not_in\') {\\n        $k = substr($k,0,-7).\':NOT IN\';\\n        $v = (!is_array($v))? explode(\',\',$v):$v;\\n        $v = array_map(\'trim\', $v);\\n    }\\n    elseif (strtolower(substr($k,-12))==\':starts_with\') {\\n        $k = substr($k,0,-12).\':LIKE\';\\n        $v = trim($v,\'%\').\'%\';\\n    }\\n    elseif (strtolower(substr($k,-10))==\':ends_with\') {\\n        $k = substr($k,0,-10).\':LIKE\';\\n        $v = \'%\'.trim($v,\'%\');\\n    }\\n    \\n    if (strtolower($v) == \'null\') {\\n        $v = null;\\n    }\\n    \\n    \\/\\/ Manually set an operator\\n    if (isset($scriptProperties[\'_op_\'.$k])) {\\n        $k = $k.\':\'.ltrim($scriptProperties[\'_op_\'.$k],\':\');\\n    }\\n    unset($scriptProperties[\'_op_\'.$k]);\\n    $filters[$k] = $v;\\n}\\n\\n\\/\\/ Read the control arguments\\n$classname = $modx->getOption(\'_classname\', $control_params,\'modResource\');\\n$pkg = $modx->getOption(\'_pkg\', $control_params);\\n$tpl = $modx->getOption(\'_tpl\', $control_params);\\n$tplOuter = $modx->getOption(\'_tplOuter\', $control_params);\\n$view = $modx->getOption(\'_view\', $control_params,\'table\');\\n$limit = (int) $modx->getOption(\'_limit\', $control_params);\\n$sortby = $modx->getOption(\'_sortby\', $control_params);\\n$sortdir = $modx->getOption(\'_sortdir\', $control_params,\'ASC\'); \\n$page = (int) $modx->getOption(\'_page\', $control_params);\\n$offset = (int) $modx->getOption(\'_offset\', $control_params);\\n$sql = $modx->getOption(\'_sql\', $control_params);\\n$style = $modx->getOption(\'_style\', $control_params, \'default\');\\n$graph = $modx->getOption(\'_graph\', $control_params);\\n$select = $modx->getOption(\'_select\', $control_params,\'*\');\\n$log_level = (int) $modx->getOption(\'_log_level\', $control_params,$modx->getOption(\'log_level\'));\\n$config = basename($modx->getOption(\'_config\', $control_params,\'default\'),\'.config.php\');\\n$debug = (int) $modx->getOption(\'_debug\', $control_params);\\n\\n$old_log_level = $modx->setLogLevel($log_level);\\n\\n\\/\\/ Load up any custom packages\\nif ($pkg) {\\n    $parts = explode(\':\',$pkg);\\n    if (isset($parts[2])) {\\n        $modx->addPackage($parts[0],$parts[1],$parts[2]);     \\n    }\\n    elseif(isset($parts[1])) {\\n        $modx->addPackage($parts[0],$parts[1]);\\n    }\\n    else {\\n        $modx->addPackage($parts[0],MODX_CORE_PATH.\'components\\/\'.$parts[0].\'\\/model\\/\');\\n    }\\n}\\n\\n$data = array();\\n$record_count = 0;\\n\\/\\/ Run raw sql?\\nif ($sql) {\\n    \\/\\/ include SQL_CALC_FOUND_ROWS in your query\\n    if ($limit) {\\n        $sql .= \' LIMIT \'.$limit;\\n        if ($offset) {\\n            $sql .= \' OFFSET \'.$offset;    \\n        }\\n    }\\n    \\/\\/ Quote any placeholders in case they are used in the query\\n    $ph = array();\\n    foreach ($placeholder_keys as $k) {\\n        $ph[$k] = $modx->quote($modx->getPlaceholder($k));\\n        $sql = str_replace(\'[[+\'.$k.\']]\', $ph[$k], $sql);\\n    }\\n    if ($debug) {\\n        return \'<div><h2><code>Query<\\/code> Snippet Debug<\\/h2><h3>Raw SQL<\\/h3><textarea rows=\\"10\\" cols=\\"60\\">\'.$sql.\'<\\/textarea>\\n            <h3>Placeholders<\\/h3>\\n            <textarea rows=\\"10\\" cols=\\"60\\">\'.print_r($ph,true).\'<\\/textarea>\\n            <h3>POST<\\/h3>\\n            <textarea rows=\\"10\\" cols=\\"60\\">\'.print_r($_POST,true).\'<\\/textarea>\\n        <\\/div>\';\\n    }\\n\\n    $result = $modx->query($sql);\\n    $data = $result->fetchAll(PDO::FETCH_ASSOC);\\n\\n    $result2 = $modx->query(\'SELECT FOUND_ROWS() as total_pages\');\\n    $data2 = $result2->fetch(PDO::FETCH_ASSOC);\\n    \\/\\/return \'<pre>\'.print_r($data2,true).\'<\\/pre>\';\\n    $record_count = $data2[\'total_pages\'];\\n}\\nelse {    \\n    $cols = array();\\n    if ($select != \'*\') {\\n        $cols = explode(\',\',$select);\\n        $cols = array_map(\'trim\', $cols);\\n    }\\n\\n    $criteria = $modx->newQuery($classname);\\n    \\/\\/ Graphing potentially needs *all* fields to function, so forcefully restricting it via \\"select\\" it is not rec\'d\\n    if (!$graph) {\\n        $criteria->select($select);\\n    }\\n    $criteria->where($filters);\\n    $record_count = $modx->getCount($classname,$criteria);\\n    $criteria->limit($limit, $offset); \\n    if ($sortby) {\\n        $criteria->sortby($sortby,$sortdir);\\n    }\\n\\n    if ($graph) {\\n        $results = $modx->getCollectionGraph($classname,$graph,$criteria);\\n\\n        \\/\\/$criteria->bindGraph($graph);\\n        \\/\\/return print_r($results,true);\\n    }\\n    else {\\n        $results = $modx->getCollection($classname,$criteria);\\n    }\\n    \\/\\/ TODO: More info displayed here\\n    if ($debug) {\\n        $criteria->prepare();\\n        return \'<div><h2><code>Query<\\/code> Snippet Debug<\\/h2><h3>Raw SQL<\\/h3><textarea rows=\\"10\\" cols=\\"60\\">\'.$criteria->toSQL().\'<\\/textarea>\\n            <h3>POST<\\/h3>\\n            <textarea rows=\\"10\\" cols=\\"60\\">\'.print_r($_POST,true).\'<\\/textarea>\\n            <h3>Control Parameters<\\/h3>\\n            <textarea rows=\\"10\\" cols=\\"60\\">\'.print_r($control_params,true).\'<\\/textarea>\\n            <h3>Filters<\\/h3>\\n            <textarea rows=\\"10\\" cols=\\"60\\">\'.print_r($filters,true).\'<\\/textarea>\\n        <\\/div>\';\\n    }\\n\\n    foreach ($results as $r) {\\n        \\/\\/ Cheap trick to flatten the hierarchy using toPlaceholders\\n        if ($graph) {\\n            $keys = $modx->toPlaceholders($r->toArray(\'\',false,true,$graph),\'tmp\'); \\/\\/ without period\\n        }\\n        else {\\n            $keys = $modx->toPlaceholders($r->toArray(),\'tmp\'); \\/\\/ without period\\n        }\\n\\n        $this_row = array();\\n        \\/\\/ Cols are set only when $graph && $select\\n        if ($cols) {\\n            foreach ($cols as $k) {\\n                \\/\\/ $k seems to come out clean when $select is used\\n                $this_row[$k] = $modx->getPlaceholder(\'tmp.\'.$k); \\/\\/ with period\\n            }\\n        }\\n        else {\\n            foreach ($keys[\'keys\'] as $k) {\\n                $clean_k = substr($k,4); \\/\\/ remove the tmp.\\n                $this_row[$clean_k] = $modx->getPlaceholder($k); \\n            }\\n        }\\n        $data[] = $this_row;\\n    }\\n\\n}\\n\\nif (empty($data)) {\\n    $modx->log(xPDO::LOG_LEVEL_DEBUG,\'[Query] No output.\');\\n    return \'\';\\n}\\n\\n$out = \'\';\\n$pagination_links = \'\';\\n\\n\\/\\/ Pagination\\nif ($limit && $record_count > $limit) {\\n    \\n    \\/\\/Pagination\\\\Pager::style($style);\\n    $pagination_links = Pagination\\\\Pager::links($record_count, $offset, $limit)\\n        ->setBaseUrl($modx->makeUrl($modx->resource->get(\'id\'),\'\',\'\',\'abs\'))\\n        ->style($style);\\n    $page_count = ceil(record_count \\/ $limit);\\n}\\n\\n\\/\\/ Default formatting (via a PHP view)\\nif (!$tpl && !$tplOuter) {\\n    $view_file = $core_path.\'views\\/\'.basename($view,\'.php\').\'.php\';    \\n    if (!file_exists($view_file)) {\\n        $view_file = $view;\\n        if (!file_exists($view_file)) {\\n            $modx->log(xPDO::LOG_LEVEL_ERROR,\'[Query] The view file \'.$view_file.\' does not exist.\');\\n            return \'The view file \'.htmlspecialchars($view_file).\' does not exist.\';\\n        }\\n    }\\n    ob_start();\\n    include $view_file;\\n    $out = ob_get_contents();\\n    ob_end_clean();\\n}\\nelseif($tpl) {\\n\\n    $use_tmp_chunk = false;\\n    if (!$innerChunk = $modx->getObject(\'modChunk\', array(\'name\' => $tpl))) {\\n        $use_tmp_chunk = true; \\/\\/ No chunk was passed... a formatting string was passed instead.\\n    }\\n    \\n    foreach ($data as $r) {\\n        if (is_object($r)) $r = $r->toArray(\'\',false,false,true); \\/\\/ Handle xPDO objects\\n        \\/\\/ Use a temporary Chunk when dealing with raw formatting strings\\n        if ($use_tmp_chunk) {\\n            $uniqid = uniqid();\\n            $innerChunk = $modx->newObject(\'modChunk\', array(\'name\' => \\"{tmp-inner}-{$uniqid}\\"));\\n            $innerChunk->setCacheable(false);    \\n            $out .= $innerChunk->process($r, $tpl);\\n        }\\n        \\/\\/ Use getChunk when a chunk name was passed\\n        else {\\n            $out .= $modx->getChunk($tpl, $r);\\n        }\\n    }\\n}\\n\\nif ($tplOuter) {\\n    $props = array(\'content\'=>$out);\\n    \\/\\/ Formatting String\\n    if (!$outerChunk = $modx->getObject(\'modChunk\', array(\'name\' => $tplOuter))) {  \\n        $uniqid = uniqid();\\n        $outerChunk = $modx->newObject(\'modChunk\', array(\'name\' => \\"{tmp-outer}-{$uniqid}\\"));\\n        $outerChunk->setCacheable(false);    \\n        $out = $outerChunk->process($props, $tplOuter);        \\n    }\\n    \\/\\/ Chunk Name\\n    else {\\n        $out = $modx->getChunk($tplOuter, $props);\\n    }\\n}\\n\\n\\/\\/ Set placeholders\\n$modx->setPlaceholder(\'page_count\',$page_count);\\n$modx->setPlaceholder(\'results\',$out);\\n$modx->setPlaceholder(\'pagination_links\',$pagination_links);\\n$modx->setLogLevel($old_log_level);\\n\\n$results = array(\\n    \'page_count\' => $page_count,\\n    \'results\' => $out,\\n    \'pagination_links\' => $pagination_links,\\n);\\n\\n\\/\\/ Cache the lookup\\n$modx->cacheManager->set($fingerprint, $results, $lifetime, $cache_opts);\\n\\nreturn $out;"}',
        'guid' => '083488dd891115793b9a5d4ca98560ca',
        'native_key' => 1,
        'signature' => 'a09a5dea888107dcfb36779c0376074e',
      ),
      '368309e736a303a4bc47c57125f116cb' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":2,"source":0,"property_preprocess":0,"name":"queryResources","description":"Like Query, but only for searching on modResource using TV optimizations. Filter arguments include modResource column names and any TV names.","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\n * @name queryResources\\n * @description Like Query, but only for searching on modResource using TV optimizations. Filter arguments include modResource column names and any TV names.\\n *\\n *\\n *  Sortby only works for regular columns.\\n *\\n * There are 3 types of queries that could be triggers:\\n *  1. Filters applied to modx_site_content columns\\n *  2. Filters applied to TV (i.e. virtual columns)\\n *  3. Filters applied to both built-in and TV columns\\n *\\n * The process goes like this:\\n *\\n * Use filters to get all matching page ids from modx_site_content.\\n * Iterate over each TV filter get all matching page ids from modx_site_tmplvar_contentvalues\\n * Find the intersect of the arrays of page ids\\n * Load data from modx_site_content (limiting by select columns where applicable)\\n * Load data from modx_site_tmplvar_contentvalues (limiting by select columns where applicable)\\n * Normalize the result set so that each row has the same keys in its array.\\n * Format and return the result.\\n *\\n * USAGE\\n *\\n *  E.g. search by TVs:\\n *  [[queryResources? &city=`city:get` &state=`state:get` &_view=`json`]]\\n *\\n *  Search by both TVs and regular columns (interface should be the same)\\n *  [[queryResources? &published=`1` &city=`city:get` &state=`state:get` &_view=`json`]]\\n *\\n * No Results - rely on MODX output filters.\\n *\\n *  [[queryResults:empty=`No results found`]]\\n *\\n *\\n * Copyright 2015 by Everett Griffiths <everett@craftsmancoding.com>\\n\\n *\\n * Control Parameters\\n * ------------------\\n * All \\"control\\" parameters begin with an underscore. They affect the functionality or formatting of the output.\\n\\n *  @param string _tpl chunk or formatting-string to format each record in the collection\\n *  @param string  _tplOuter chunk or formatting-string to wrap the result set. Requires the [[+content]] placeholder.\\n *  @param string _view oldschool php file to format the output, see the views folder.\\n *      Some samples are provided, e.g. \'table\', \'json\'. If _tpl\\n *      and _tplOuter are provided, the _view parameter is ignored.  Default: table.php\\n *  @param integer _limit limits the number of results returned, also sets the results shown per page.\\n *  @param integer _offset offsets the first record returned, e.g. for pagination.\\n *  @param string _sortby column to sort by\\n *  @param string _sortdir sort direction. Usually ASC or DESC, but may also contain complex sorting rules.\\n *  @param string _style one of Pagination\'s styles (see https:\\/\\/github.com\\/craftsmancoding\\/pagination)\\n *  @param string _select controls which columns to select for a getIterator. Default: *\\n *  @param string _config sets a pagination formatting pallette, e.g. \\"default\\".\\n *      Corresponding file must exist inside the config directory, e.g. \\"default.config.php\\"\\n *  @param integer _log_level overrides the MODX log_level system setting. Defaults to System Setting.\\n *  @param boolean _debug triggers debugging information to be set.\\n *  @param string _rename JSON hash used to rename any output attributes, for easier use in Ajax requests. E.g. if your Ajax script required the results include attributes named \\"city\\" and \\"desc\\" but your pages stored this info in the pagetitle and description fields, you can rename the values by setting `{\\"pagetitle\\":\\"city\\",\\"description\\":\\"desc\\"}  i.e. OLD Value:New Value\\n *\\n * Filter Parameters\\n * ----------------\\n * Any parameter that does not begin with an underscore is considered a filter parameter.\\n * A filter parameter should be a regular column from the modx_site_content table, otherwise\\n * it is considered a TV name (i.e. a virtual column)\\n *\\n *\\n * Input Operators\\n * ---------------\\n *  Apply these to the end of any parameter name with a colon, e.g. &firstname:LIKE=`Sue`\\n *  E          =   equals\\n *  NE         !=  not equal\\n *  GT         >   greater than\\n *  LT         <   less than\\n *  GTE        >=  greater than or equal to\\n *  LTE        <=  less than or equal to\\n *  LIKE       LIKE -- Query will automatically quote the input value as \'%value%\'\\n *  NOT_LIKE   NOT LIKE\\n *  NOT_IN     NOT IN\\n *  IN         IN\\n *  STARTS_WITH behaves like \\"LIKE\\", but quotes the value as \'value%\'\\n *  ENDS_WITH behaves like \\"LIKE\\", but quotes the value as \'%value\'\\n *\\n *\\n * Input Value Modifiers\\n * ---------------\\n * Inspired by MODX\'s Output Filters (see http:\\/\\/goo.gl\\/bSzfwi), the Query & queryResources Snippets support\\n * dynamic inputs via \\"value modifiers\\" that mimic the syntax used by MODX for its output\\n * filters (aka \\"output modifiers).  This is useful for building search forms or enabling pagination.\\n * For example, you can change the &id argument dynamically by setting a URL parameter, then you\\n * can adjust your Query snippet call to read the $_GET[\'pageid\'] variable:\\n *\\n *      [[!queryResources? &id=`pageid:get`]]\\n *\\n * There are 3 value modifiers included:\\n *\\n *  get : causes the named value to read from the $_GET array.  $options = default value.\\n *  post : causes the named value to read from the $_POST array. $options = default value.\\n *  decode : runs json_decode on the input. Useful if you need to pass an array as an argument.\\n *\\n * You can also supply your own Snippet names to be used as value modifiers instead of relying on the included get, post\\n * and decode. Your custom value modifiers should accept the following inputs\\n *  $input : the value sent to the snippet.  E.g. in &_sortby=`xyz:customvaluemodifier`, the $input is \\"xyz\\"\\n *  $options : any extra option. E.g. &_sortby=`xyz:customvaluemodifier=123`, the $options is \\"123\\". These may be quoted any way you prefer.\\n *\\n * WARNING: use value modifiers with extreme caution! Query does not perform any data sanitization, so these\\n * could be exploited via SQL injection if you exposed a value that should not be exposed (like &_sql).\\n *\\n *\\n *\\n * Variables\\n * ---------\\n * @var $modx modX\\n * @var $scriptProperties array\\n *\\n * @package query\\n *\\/\\n\\/\\/ Caching needs to encapsulate changes in GET and POST since input filters mean that the $scriptProperties may not change\\n$cache_opts = array(xPDO::OPT_CACHE_KEY => \'query\');\\n$lifetime = 0;\\n$fingerprint = md5(\'queryResources\'.serialize(array($scriptProperties,$_POST,$_GET)));\\nif ($results = $modx->cacheManager->get($fingerprint, $cache_opts))\\n{\\n    $modx->log(xPDO::LOG_LEVEL_INFO,\'[queryResources] returning results from cache.\');\\n    $modx->setPlaceholder(\'page_count\',$results[\'page_count\']);\\n    $modx->setPlaceholder(\'results\',$results[\'results\']);\\n    $modx->setPlaceholder(\'pagination_links\',$results[\'pagination_links\']);\\n\\n    return $results[\'results\'];\\n}\\n\\n$core_path = $modx->getOption(\'query.core_path\',\'\',MODX_CORE_PATH.\'components\\/query\\/\');\\nrequire_once $core_path .\'vendor\\/autoload.php\';\\n\\n\\/\\/ Read TVs from Cache\\nif (!$tvlookup_by_name = $modx->cacheManager->get(\'tvlookup_by_name\', $cache_opts))\\n{\\n    $query = $modx->newQuery(\'modTemplateVar\');\\n    $query->select(array(\'id\',\'name\'));\\n    $tvs = $modx->getIterator(\'modTemplateVar\', $query);\\n    $tvlookup_by_name = array();\\n    $tvlookup_by_id = array();\\n    foreach ($tvs as $t)\\n    {\\n        $tvlookup_by_name[$t->get(\'name\')] = $t->get(\'id\');\\n        $tvlookup_by_id[$t->get(\'id\')] = $t->get(\'name\');\\n    }\\n\\n    $modx->cacheManager->set(\'tvlookup_by_name\', $tvlookup_by_name, $lifetime, $cache_opts);\\n    $modx->cacheManager->set(\'tvlookup_by_id\', $tvlookup_by_id, $lifetime, $cache_opts);\\n}\\n\\n$tvlookup_by_name = $modx->cacheManager->get(\'tvlookup_by_name\', $cache_opts);\\n$tvlookup_by_id = $modx->cacheManager->get(\'tvlookup_by_id\', $cache_opts);\\n\\n\\n\\n$page_cols = array_keys($modx->getFields(\'modResource\'));\\n\\n\\n\\/\\/ TODO: Restricted properties (cannot use the get: and post: convenience methods)\\n\\/\\/ Process the raw $scriptProperties into filters and control_params.\\n\\/\\/ FYI: We need to translate some stuff here (e.g. \'<=\' becomes \'LTE\') due to limitations in the Snippet Syntax.\\n\\/\\/ See http:\\/\\/rtfm.modx.com\\/xpdo\\/2.x\\/class-reference\\/xpdoquery\\/xpdoquery.where\\n$control_params = array();\\n\\/\\/$scriptProperties; \\/\\/ not a reference!\\n$filters = array();\\n$tvfilters = array();\\n\\/\\/ We track which placeholders we set\\n$placeholder_keys = array();\\n$page_count = 1; \\/\\/ default is one page\\n\\nforeach ($scriptProperties as $k => $v) {\\n\\n    \\/\\/ Dynamically modify values via our \\"input filters\\"\\n    $filter = null;\\n    $raw_k = $k;\\n    \\/\\/ $v might be something like `year:get=2012`\\n    preg_match(\\"\\/^(.*):((\\\\w+)(=[\'`\\\\\\"]?([^\'`\\\\\\"]*)[\'`\\\\\\"]?)?)$\\/i\\", $v, $matches);\\n    if ($matches) {\\n        $filter = (isset($matches[3]))? $matches[3] : \'\';\\n        $x = (isset($matches[1]))? $matches[1] : \'\'; \\/\\/ whatever\'s to the left of the filter, e.g. \'year\'\\n        $y = (isset($matches[4]))? $matches[4] : \'\'; \\/\\/ any option, e.g. =\\"2012\\"\\n\\n        \\/\\/ Input Modifiers\\n        \\/\\/ Don\'t use getOption here because it will read db config data if there is no $_POST data!\\n        if (strtolower($filter) == \'get\') {\\n            $v = (isset($_GET[$x]))? $_GET[$x]: ltrim($y,\'=\');\\n        }\\n        elseif (strtolower($filter) == \'post\') {\\n            $v = (isset($_POST[$x]))? $_POST[$x]: ltrim($y,\'=\');\\n        }\\n        elseif (strtolower($filter) == \'decode\') {\\n            $v = json_decode($matches[1]);\\n        }\\n        else {\\n            $v = $modx->runSnippet($filter,array(\'input\'=>$x,\'options\'=>$y));\\n        }\\n    }\\n\\n    \\/\\/ All control_params begin with an underscore\\n    if ($k[0] == \'_\') {\\n        $control_params[$k] = $v;\\n        unset($scriptProperties[$k]);\\n        continue;\\n    }\\n\\n    \\/\\/ Placeholders are used for debugging, raw SQL, and ???\\n    $placeholder_keys[] = \'query.\'.$raw_k;\\n    $modx->toPlaceholder($raw_k,htmlspecialchars($v),\'query\');\\n\\n    \\/\\/ Modify the keys (i.e. translate the syntax to xPDO)\\n    if (strtolower(substr($k,-2))==\':e\') {\\n        $k = substr($k,0,-2).\':=\';\\n    }\\n    elseif (strtolower(substr($k,-3))==\':ne\') {\\n        $k = substr($k,0,-3).\':!=\';\\n    }\\n    elseif (strtolower(substr($k,-3))==\':gt\') {\\n        $k = substr($k,0,-3).\':>\';\\n    }\\n    elseif (strtolower(substr($k,-4))==\':gte\') {\\n        $k = substr($k,0,-4).\':>=\';\\n    }\\n    elseif (strtolower(substr($k,-3))==\':lt\') {\\n        $k = substr($k,0,-3).\':<\';\\n    }\\n    elseif (strtolower(substr($k,-4))==\':lte\') {\\n        $k = substr($k,0,-4).\':<=\';\\n    }\\n    elseif (strtolower(substr($k,-5))==\':like\') {\\n        $v = \'%\'.trim($v,\'%\').\'%\';\\n    }\\n    elseif (strtolower(substr($k,-9))==\':not_like\') {\\n        $k = substr($k,0,-9).\':NOT LIKE\';\\n        $v = \'%\'.trim($v,\'%\').\'%\';\\n    }\\n    elseif (strtolower(substr($k,-3))==\':in\') {\\n        $v = (!is_array($v))? explode(\',\',$v):$v;\\n        $v = array_map(\'trim\', $v);\\n    }\\n    elseif (strtolower(substr($k,-7))==\':not_in\') {\\n        $k = substr($k,0,-7).\':NOT IN\';\\n        $v = (!is_array($v))? explode(\',\',$v):$v;\\n        $v = array_map(\'trim\', $v);\\n    }\\n    elseif (strtolower(substr($k,-12))==\':starts_with\') {\\n        $k = substr($k,0,-12).\':LIKE\';\\n        $v = trim($v,\'%\').\'%\';\\n    }\\n    elseif (strtolower(substr($k,-10))==\':ends_with\') {\\n        $k = substr($k,0,-10).\':LIKE\';\\n        $v = \'%\'.trim($v,\'%\');\\n    }\\n\\n    if (strtolower($v) == \'null\') {\\n        $v = null;\\n    }\\n\\n    \\/\\/ Manually set an operator\\n    if (isset($scriptProperties[\'_op_\'.$k])) {\\n        $k = $k.\':\'.ltrim($scriptProperties[\'_op_\'.$k],\':\');\\n    }\\n    unset($scriptProperties[\'_op_\'.$k]);\\n\\n    \\/\\/ Does the column belong to the site_content table? Or does it represent a TV?\\n    if (strpos($k, \':\') !== false)\\n    {\\n        $tmp = explode(\':\', $k);\\n        if (count($tmp) == 2)\\n        {\\n            $column_name = $tmp[0];\\n        }\\n        else\\n        {\\n            $column_name = $tmp[1];\\n        }\\n    }\\n    else\\n    {\\n        $column_name = $k;\\n    }\\n\\n    if (in_array($column_name, $page_cols))\\n    {\\n        $filters[$k] = $v;\\n    }\\n    else\\n    {\\n        $k = str_replace($column_name,\'value\',$k);\\n        $tvfilters[] = array(\\n            \'tvname\' => $column_name,\\n            \'filter\' => $k,\\n            \'value\' => $v\\n        );\\n    }\\n}\\n\\n\\/\\/ Read the control arguments\\n$tpl = $modx->getOption(\'_tpl\', $control_params);\\n$tplOuter = $modx->getOption(\'_tplOuter\', $control_params);\\n$view = $modx->getOption(\'_view\', $control_params,\'table\');\\n$limit = (int) $modx->getOption(\'_limit\', $control_params);\\n$sortby = $modx->getOption(\'_sortby\', $control_params);\\n$sortdir = $modx->getOption(\'_sortdir\', $control_params,\'ASC\');\\n$page = (int) $modx->getOption(\'_page\', $control_params);\\n$offset = (int) $modx->getOption(\'_offset\', $control_params);\\n$sql = $modx->getOption(\'_sql\', $control_params);\\n$style = $modx->getOption(\'_style\', $control_params, \'default\');\\n$select = $modx->getOption(\'_select\', $control_params,\'*\');\\n$log_level = (int) $modx->getOption(\'_log_level\', $control_params,$modx->getOption(\'log_level\'));\\n$config = basename($modx->getOption(\'_config\', $control_params,\'default\'),\'.config.php\');\\n$debug = (int) $modx->getOption(\'_debug\', $control_params);\\n$rename = $modx->getOption(\'_rename\', $control_params);\\n\\nif ($rename && !is_array($rename))\\n{\\n    $rename = json_decode($rename,true);\\n    if(!is_array($rename))\\n    {\\n        $modx->log(xPDO::LOG_LEVEL_DEBUG,\'[queryResources] _map input must be a valid JSON hash\');\\n    }\\n}\\n\\n\\n$old_log_level = $modx->setLogLevel($log_level);\\n\\n\\/\\/ Get page ids from primary query (if filters are present)\\n$intersects = array();\\nif ($filters)\\n{\\n    $criteria = $modx->newQuery(\'modResource\');\\n    $criteria->select(\'id\');\\n    $criteria->where($filters);\\n\\n    if ($results = $modx->getIterator(\'modResource\',$criteria))\\n    {\\n        $this_set = array();\\n        foreach ($results as $r)\\n        {\\n            $this_set[] = $r->get(\'id\');\\n        }\\n        $intersects[] = $this_set;\\n    }\\n}\\n\\nif ($tvfilters)\\n{\\n    foreach($tvfilters as $tf)\\n    {\\n        if (empty($tf[\'value\'])) continue;\\n        \\n        $criteria = $modx->newQuery(\'modTemplateVarResource\');\\n        $criteria->select(\'contentid\');\\n        $this_filter = array(\\n            \'tmplvarid\' => $tvlookup_by_name[$tf[\'tvname\']],\\n            $tf[\'filter\'] => $tf[\'value\']\\n        );\\n\\n        $criteria->where($this_filter);\\n        if ($results = $modx->getIterator(\'modTemplateVarResource\',$criteria))\\n        {\\n            $this_set = array();\\n            foreach ($results as $r)\\n            {\\n                $this_set[] = $r->get(\'contentid\');\\n            }\\n            $intersects[] = $this_set;\\n        }\\n    }\\n}\\n\\n\\nif (count($intersects) > 1)\\n{\\n    $intersects = call_user_func_array(\'array_intersect\', $intersects);\\n}\\nelse\\n{\\n    $intersects = array_shift($intersects);\\n}\\n\\/\\/ Page ids here!\\n$intersects = array_values($intersects);\\n$record_count = count($intersects);\\nif ($debug) {\\n    return \'<div><h2><code>queryResources<\\/code> Snippet Debug<\\/h2><h3>Primary Filters<\\/h3><textarea rows=\\"10\\" cols=\\"60\\">\'.print_r($filters,true).\'<\\/textarea>\\n        <h3>TV Filters<\\/h3>\\n        <textarea rows=\\"10\\" cols=\\"60\\">\'.print_r($tvfilters,true).\'<\\/textarea>\\n        <h3>Matching Page IDs<\\/h3>\\n        <textarea rows=\\"10\\" cols=\\"60\\">\'.print_r($intersects,true).\'<\\/textarea>\\n    <\\/div>\';\\n}\\n\\n$real_cols = array(); \\/\\/ real columns in modx_site_content\\n$virtual_cols = array(); \\/\\/ virtual columns are TVs\\nif ($select != \'*\') {\\n    $cols = explode(\',\',$select);\\n    $cols = array_map(\'trim\', $cols);\\n    $virtual_cols = array_diff($cols, $page_cols);\\n    $real_cols = array_intersect($page_cols, $cols);\\n    if (!in_array(\'id\', $real_cols))\\n    {\\n        $real_cols[] = \'id\'; \\/\\/ make sure we have the pk\\n    }\\n}\\n\\n\\n\\n$data = array();\\n$tvdata = array();\\n\\n\\n\\/*\\n * Load up TVs ONLY when needed (i.e. if virtual columns were specified)\\n * Format should be:\\n * array(\\n *  [page_id] => array(\\n *      [tv-name] => tv-value\\n *      [other-tv-name] => other value\\n *   ),\\n *   \\/\\/ ...etc...\\n * )\\n *\\/\\nif ($virtual_cols || $select == \'*\') {\\n    $criteria = $modx->newQuery(\'modTemplateVarResource\');\\n\\n\\/\\/ Get \'em all\\n    if (empty($virtual_cols) && $select == \'*\') {\\n        $this_filter = array(\\n            \'contentid:IN\' => $intersects,\\n        );\\n    } \\/\\/ Only get the ones specified\\n    else {\\n        $virtual_col_ids = array();\\n        foreach ($virtual_cols as $vc) {\\n            $virtual_col_ids[] = $tvlookup_by_name[$vc];\\n        }\\n        $this_filter = array(\\n            \'contentid:IN\' => $intersects,\\n            \'tmplvarid:IN\' => $virtual_col_ids\\n        );\\n    }\\n\\n    $criteria->where($this_filter);\\n\\n    if ($results = $modx->getIterator(\'modTemplateVarResource\', $criteria)) {\\n        \\/\\/return $criteria->toSQL();\\n        foreach ($results as $r) {\\n            $tvdata[$r->get(\'contentid\')][$tvlookup_by_id[$r->get(\'tmplvarid\')]] = $r->get(\'value\');\\n        }\\n    }\\n}\\n\\/\\/ Load up the base pages\\n$criteria = $modx->newQuery(\'modResource\');\\n$criteria->select($real_cols); \\/\\/ Only the built-in columns here\\n$criteria->where(array(\'id:IN\'=>$intersects));\\n\\n$criteria->limit($limit, $offset);\\nif ($sortby)\\n{\\n    $criteria->sortby($sortby,$sortdir);\\n}\\n\\n\\n\\/\\/ Load up pages\\nif($results = $modx->getIterator(\'modResource\',$criteria))\\n{\\n    foreach ($results as $r) {\\n        $this_row = $r->toArray(\'\',false,true);\\n        if (isset($tvdata[ $r->get(\'id\') ]))\\n        {\\n            $this_row = array_merge($this_row, $tvdata[ $r->get(\'id\') ]);\\n        }\\n        \\/\\/ Map...\\n        if ($rename)\\n        {\\n            foreach ($rename as $old => $new)\\n            {\\n                if (isset($this_row[$old]))\\n                {\\n                   $this_row[$new] = $this_row[$old];\\n                   unset($this_row[$old]);\\n                }\\n            }\\n        }\\n        $data[] = $this_row;\\n    }\\n}\\nif (empty($data)) {\\n    $modx->log(xPDO::LOG_LEVEL_DEBUG,\'[queryResources] No output.\');\\n    return \'\';\\n}\\n\\n$out = \'\';\\n$pagination_links = \'\';\\n\\n\\/\\/ Pagination\\nif ($limit && $record_count > $limit) {\\n\\n    $pagination_links = Pagination\\\\Pager::links($record_count, $offset, $limit)\\n        ->setBaseUrl($modx->makeUrl($modx->resource->get(\'id\'),\'\',\'\',\'abs\'))\\n        ->style($style);\\n    $page_count = ceil(record_count \\/ $limit);\\n}\\n\\n\\/\\/ Default formatting (via a PHP view)\\nif (!$tpl && !$tplOuter) {\\n    $view_file = $core_path.\'views\\/\'.basename($view,\'.php\').\'.php\';\\n    if (!file_exists($view_file)) {\\n        $view_file = $view;\\n        if (!file_exists($view_file)) {\\n            $modx->log(xPDO::LOG_LEVEL_ERROR,\'[Query] The view file \'.$view_file.\' does not exist.\');\\n            return \'The view file \'.htmlspecialchars($view_file).\' does not exist.\';\\n        }\\n    }\\n    ob_start();\\n    include $view_file;\\n    $out = ob_get_contents();\\n    ob_end_clean();\\n}\\nelseif($tpl)\\n{\\n\\n    $use_tmp_chunk = false;\\n    if (!$innerChunk = $modx->getObject(\'modChunk\', array(\'name\' => $tpl))) {\\n        $use_tmp_chunk = true; \\/\\/ No chunk was passed... a formatting string was passed instead.\\n    }\\n\\n    foreach ($data as $r) {\\n        if (is_object($r)) $r = $r->toArray(\'\',false,false,true); \\/\\/ Handle xPDO objects\\n        \\/\\/ Use a temporary Chunk when dealing with raw formatting strings\\n        if ($use_tmp_chunk) {\\n            $uniqid = uniqid();\\n            $innerChunk = $modx->newObject(\'modChunk\', array(\'name\' => \\"{tmp-inner}-{$uniqid}\\"));\\n            $innerChunk->setCacheable(false);\\n            $out .= $innerChunk->process($r, $tpl);\\n        }\\n        \\/\\/ Use getChunk when a chunk name was passed\\n        else {\\n            $out .= $modx->getChunk($tpl, $r);\\n        }\\n    }\\n}\\n\\nif ($tplOuter) {\\n    $props = array(\'content\'=>$out);\\n    \\/\\/ Formatting String\\n    if (!$outerChunk = $modx->getObject(\'modChunk\', array(\'name\' => $tplOuter))) {\\n        $uniqid = uniqid();\\n        $outerChunk = $modx->newObject(\'modChunk\', array(\'name\' => \\"{tmp-outer}-{$uniqid}\\"));\\n        $outerChunk->setCacheable(false);\\n        $out = $outerChunk->process($props, $tplOuter);\\n    }\\n    \\/\\/ Chunk Name\\n    else {\\n        $out = $modx->getChunk($tplOuter, $props);\\n    }\\n}\\n\\n\\/\\/ Set placeholders\\n$modx->setPlaceholder(\'page_count\',$page_count);\\n$modx->setPlaceholder(\'results\',$out);\\n$modx->setPlaceholder(\'pagination_links\',$pagination_links);\\n$modx->setLogLevel($old_log_level);\\n\\n$results = array(\\n    \'page_count\' => $page_count,\\n    \'results\' => $out,\\n    \'pagination_links\' => $pagination_links,\\n);\\n\\n\\/\\/ Cache the lookup\\n$modx->cacheManager->set($fingerprint, $results, $lifetime, $cache_opts);\\n\\nreturn $out;","locked":0,"properties":"a:13:{s:4:\\"_tpl\\";a:7:{s:4:\\"name\\";s:4:\\"_tpl\\";s:4:\\"desc\\";s:66:\\"chunk or formatting-string to format each record in the collection\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:9:\\"_tplOuter\\";a:7:{s:4:\\"name\\";s:9:\\"_tplOuter\\";s:4:\\"desc\\";s:89:\\"chunk or formatting-string to wrap the result set. Requires the [[+content]] placeholder.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:5:\\"_view\\";a:7:{s:4:\\"name\\";s:5:\\"_view\\";s:4:\\"desc\\";s:62:\\"oldschool php file to format the output, see the views folder.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:6:\\"_limit\\";a:7:{s:4:\\"name\\";s:6:\\"_limit\\";s:4:\\"desc\\";s:76:\\"limits the number of results returned, also sets the results shown per page.\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:7:\\"_offset\\";a:7:{s:4:\\"name\\";s:7:\\"_offset\\";s:4:\\"desc\\";s:55:\\"offsets the first record returned, e.g. for pagination.\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:7:\\"_sortby\\";a:7:{s:4:\\"name\\";s:7:\\"_sortby\\";s:4:\\"desc\\";s:17:\\"column to sort by\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:8:\\"_sortdir\\";a:7:{s:4:\\"name\\";s:8:\\"_sortdir\\";s:4:\\"desc\\";s:80:\\"sort direction. Usually ASC or DESC, but may also contain complex sorting rules.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:6:\\"_style\\";a:7:{s:4:\\"name\\";s:6:\\"_style\\";s:4:\\"desc\\";s:78:\\"one of Pagination\'s styles (see https:\\/\\/github.com\\/craftsmancoding\\/pagination)\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:7:\\"_select\\";a:7:{s:4:\\"name\\";s:7:\\"_select\\";s:4:\\"desc\\";s:62:\\"controls which columns to select for a getIterator. Default: *\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:7:\\"_config\\";a:7:{s:4:\\"name\\";s:7:\\"_config\\";s:4:\\"desc\\";s:54:\\"sets a pagination formatting pallette, e.g. \\"default\\".\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:10:\\"_log_level\\";a:7:{s:4:\\"name\\";s:10:\\"_log_level\\";s:4:\\"desc\\";s:72:\\"overrides the MODX log_level system setting. Defaults to System Setting.\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:6:\\"_debug\\";a:7:{s:4:\\"name\\";s:6:\\"_debug\\";s:4:\\"desc\\";s:41:\\"triggers debugging information to be set.\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}s:7:\\"_rename\\";a:7:{s:4:\\"name\\";s:7:\\"_rename\\";s:4:\\"desc\\";s:347:\\"JSON hash used to rename any output attributes, for easier use in Ajax requests. E.g. if your Ajax script required the results include attributes named \\"city\\" and \\"desc\\" but your pages stored this info in the pagetitle and description fields, you can rename the values by setting `{\\"pagetitle\\":\\"city\\",\\"description\\":\\"desc\\"} i.e. OLD Value:New Value\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";N;s:4:\\"area\\";s:0:\\"\\";}}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * @name queryResources\\n * @description Like Query, but only for searching on modResource using TV optimizations. Filter arguments include modResource column names and any TV names.\\n *\\n *\\n *  Sortby only works for regular columns.\\n *\\n * There are 3 types of queries that could be triggers:\\n *  1. Filters applied to modx_site_content columns\\n *  2. Filters applied to TV (i.e. virtual columns)\\n *  3. Filters applied to both built-in and TV columns\\n *\\n * The process goes like this:\\n *\\n * Use filters to get all matching page ids from modx_site_content.\\n * Iterate over each TV filter get all matching page ids from modx_site_tmplvar_contentvalues\\n * Find the intersect of the arrays of page ids\\n * Load data from modx_site_content (limiting by select columns where applicable)\\n * Load data from modx_site_tmplvar_contentvalues (limiting by select columns where applicable)\\n * Normalize the result set so that each row has the same keys in its array.\\n * Format and return the result.\\n *\\n * USAGE\\n *\\n *  E.g. search by TVs:\\n *  [[queryResources? &city=`city:get` &state=`state:get` &_view=`json`]]\\n *\\n *  Search by both TVs and regular columns (interface should be the same)\\n *  [[queryResources? &published=`1` &city=`city:get` &state=`state:get` &_view=`json`]]\\n *\\n * No Results - rely on MODX output filters.\\n *\\n *  [[queryResults:empty=`No results found`]]\\n *\\n *\\n * Copyright 2015 by Everett Griffiths <everett@craftsmancoding.com>\\n\\n *\\n * Control Parameters\\n * ------------------\\n * All \\"control\\" parameters begin with an underscore. They affect the functionality or formatting of the output.\\n\\n *  @param string _tpl chunk or formatting-string to format each record in the collection\\n *  @param string  _tplOuter chunk or formatting-string to wrap the result set. Requires the [[+content]] placeholder.\\n *  @param string _view oldschool php file to format the output, see the views folder.\\n *      Some samples are provided, e.g. \'table\', \'json\'. If _tpl\\n *      and _tplOuter are provided, the _view parameter is ignored.  Default: table.php\\n *  @param integer _limit limits the number of results returned, also sets the results shown per page.\\n *  @param integer _offset offsets the first record returned, e.g. for pagination.\\n *  @param string _sortby column to sort by\\n *  @param string _sortdir sort direction. Usually ASC or DESC, but may also contain complex sorting rules.\\n *  @param string _style one of Pagination\'s styles (see https:\\/\\/github.com\\/craftsmancoding\\/pagination)\\n *  @param string _select controls which columns to select for a getIterator. Default: *\\n *  @param string _config sets a pagination formatting pallette, e.g. \\"default\\".\\n *      Corresponding file must exist inside the config directory, e.g. \\"default.config.php\\"\\n *  @param integer _log_level overrides the MODX log_level system setting. Defaults to System Setting.\\n *  @param boolean _debug triggers debugging information to be set.\\n *  @param string _rename JSON hash used to rename any output attributes, for easier use in Ajax requests. E.g. if your Ajax script required the results include attributes named \\"city\\" and \\"desc\\" but your pages stored this info in the pagetitle and description fields, you can rename the values by setting `{\\"pagetitle\\":\\"city\\",\\"description\\":\\"desc\\"}  i.e. OLD Value:New Value\\n *\\n * Filter Parameters\\n * ----------------\\n * Any parameter that does not begin with an underscore is considered a filter parameter.\\n * A filter parameter should be a regular column from the modx_site_content table, otherwise\\n * it is considered a TV name (i.e. a virtual column)\\n *\\n *\\n * Input Operators\\n * ---------------\\n *  Apply these to the end of any parameter name with a colon, e.g. &firstname:LIKE=`Sue`\\n *  E          =   equals\\n *  NE         !=  not equal\\n *  GT         >   greater than\\n *  LT         <   less than\\n *  GTE        >=  greater than or equal to\\n *  LTE        <=  less than or equal to\\n *  LIKE       LIKE -- Query will automatically quote the input value as \'%value%\'\\n *  NOT_LIKE   NOT LIKE\\n *  NOT_IN     NOT IN\\n *  IN         IN\\n *  STARTS_WITH behaves like \\"LIKE\\", but quotes the value as \'value%\'\\n *  ENDS_WITH behaves like \\"LIKE\\", but quotes the value as \'%value\'\\n *\\n *\\n * Input Value Modifiers\\n * ---------------\\n * Inspired by MODX\'s Output Filters (see http:\\/\\/goo.gl\\/bSzfwi), the Query & queryResources Snippets support\\n * dynamic inputs via \\"value modifiers\\" that mimic the syntax used by MODX for its output\\n * filters (aka \\"output modifiers).  This is useful for building search forms or enabling pagination.\\n * For example, you can change the &id argument dynamically by setting a URL parameter, then you\\n * can adjust your Query snippet call to read the $_GET[\'pageid\'] variable:\\n *\\n *      [[!queryResources? &id=`pageid:get`]]\\n *\\n * There are 3 value modifiers included:\\n *\\n *  get : causes the named value to read from the $_GET array.  $options = default value.\\n *  post : causes the named value to read from the $_POST array. $options = default value.\\n *  decode : runs json_decode on the input. Useful if you need to pass an array as an argument.\\n *\\n * You can also supply your own Snippet names to be used as value modifiers instead of relying on the included get, post\\n * and decode. Your custom value modifiers should accept the following inputs\\n *  $input : the value sent to the snippet.  E.g. in &_sortby=`xyz:customvaluemodifier`, the $input is \\"xyz\\"\\n *  $options : any extra option. E.g. &_sortby=`xyz:customvaluemodifier=123`, the $options is \\"123\\". These may be quoted any way you prefer.\\n *\\n * WARNING: use value modifiers with extreme caution! Query does not perform any data sanitization, so these\\n * could be exploited via SQL injection if you exposed a value that should not be exposed (like &_sql).\\n *\\n *\\n *\\n * Variables\\n * ---------\\n * @var $modx modX\\n * @var $scriptProperties array\\n *\\n * @package query\\n *\\/\\n\\/\\/ Caching needs to encapsulate changes in GET and POST since input filters mean that the $scriptProperties may not change\\n$cache_opts = array(xPDO::OPT_CACHE_KEY => \'query\');\\n$lifetime = 0;\\n$fingerprint = md5(\'queryResources\'.serialize(array($scriptProperties,$_POST,$_GET)));\\nif ($results = $modx->cacheManager->get($fingerprint, $cache_opts))\\n{\\n    $modx->log(xPDO::LOG_LEVEL_INFO,\'[queryResources] returning results from cache.\');\\n    $modx->setPlaceholder(\'page_count\',$results[\'page_count\']);\\n    $modx->setPlaceholder(\'results\',$results[\'results\']);\\n    $modx->setPlaceholder(\'pagination_links\',$results[\'pagination_links\']);\\n\\n    return $results[\'results\'];\\n}\\n\\n$core_path = $modx->getOption(\'query.core_path\',\'\',MODX_CORE_PATH.\'components\\/query\\/\');\\nrequire_once $core_path .\'vendor\\/autoload.php\';\\n\\n\\/\\/ Read TVs from Cache\\nif (!$tvlookup_by_name = $modx->cacheManager->get(\'tvlookup_by_name\', $cache_opts))\\n{\\n    $query = $modx->newQuery(\'modTemplateVar\');\\n    $query->select(array(\'id\',\'name\'));\\n    $tvs = $modx->getIterator(\'modTemplateVar\', $query);\\n    $tvlookup_by_name = array();\\n    $tvlookup_by_id = array();\\n    foreach ($tvs as $t)\\n    {\\n        $tvlookup_by_name[$t->get(\'name\')] = $t->get(\'id\');\\n        $tvlookup_by_id[$t->get(\'id\')] = $t->get(\'name\');\\n    }\\n\\n    $modx->cacheManager->set(\'tvlookup_by_name\', $tvlookup_by_name, $lifetime, $cache_opts);\\n    $modx->cacheManager->set(\'tvlookup_by_id\', $tvlookup_by_id, $lifetime, $cache_opts);\\n}\\n\\n$tvlookup_by_name = $modx->cacheManager->get(\'tvlookup_by_name\', $cache_opts);\\n$tvlookup_by_id = $modx->cacheManager->get(\'tvlookup_by_id\', $cache_opts);\\n\\n\\n\\n$page_cols = array_keys($modx->getFields(\'modResource\'));\\n\\n\\n\\/\\/ TODO: Restricted properties (cannot use the get: and post: convenience methods)\\n\\/\\/ Process the raw $scriptProperties into filters and control_params.\\n\\/\\/ FYI: We need to translate some stuff here (e.g. \'<=\' becomes \'LTE\') due to limitations in the Snippet Syntax.\\n\\/\\/ See http:\\/\\/rtfm.modx.com\\/xpdo\\/2.x\\/class-reference\\/xpdoquery\\/xpdoquery.where\\n$control_params = array();\\n\\/\\/$scriptProperties; \\/\\/ not a reference!\\n$filters = array();\\n$tvfilters = array();\\n\\/\\/ We track which placeholders we set\\n$placeholder_keys = array();\\n$page_count = 1; \\/\\/ default is one page\\n\\nforeach ($scriptProperties as $k => $v) {\\n\\n    \\/\\/ Dynamically modify values via our \\"input filters\\"\\n    $filter = null;\\n    $raw_k = $k;\\n    \\/\\/ $v might be something like `year:get=2012`\\n    preg_match(\\"\\/^(.*):((\\\\w+)(=[\'`\\\\\\"]?([^\'`\\\\\\"]*)[\'`\\\\\\"]?)?)$\\/i\\", $v, $matches);\\n    if ($matches) {\\n        $filter = (isset($matches[3]))? $matches[3] : \'\';\\n        $x = (isset($matches[1]))? $matches[1] : \'\'; \\/\\/ whatever\'s to the left of the filter, e.g. \'year\'\\n        $y = (isset($matches[4]))? $matches[4] : \'\'; \\/\\/ any option, e.g. =\\"2012\\"\\n\\n        \\/\\/ Input Modifiers\\n        \\/\\/ Don\'t use getOption here because it will read db config data if there is no $_POST data!\\n        if (strtolower($filter) == \'get\') {\\n            $v = (isset($_GET[$x]))? $_GET[$x]: ltrim($y,\'=\');\\n        }\\n        elseif (strtolower($filter) == \'post\') {\\n            $v = (isset($_POST[$x]))? $_POST[$x]: ltrim($y,\'=\');\\n        }\\n        elseif (strtolower($filter) == \'decode\') {\\n            $v = json_decode($matches[1]);\\n        }\\n        else {\\n            $v = $modx->runSnippet($filter,array(\'input\'=>$x,\'options\'=>$y));\\n        }\\n    }\\n\\n    \\/\\/ All control_params begin with an underscore\\n    if ($k[0] == \'_\') {\\n        $control_params[$k] = $v;\\n        unset($scriptProperties[$k]);\\n        continue;\\n    }\\n\\n    \\/\\/ Placeholders are used for debugging, raw SQL, and ???\\n    $placeholder_keys[] = \'query.\'.$raw_k;\\n    $modx->toPlaceholder($raw_k,htmlspecialchars($v),\'query\');\\n\\n    \\/\\/ Modify the keys (i.e. translate the syntax to xPDO)\\n    if (strtolower(substr($k,-2))==\':e\') {\\n        $k = substr($k,0,-2).\':=\';\\n    }\\n    elseif (strtolower(substr($k,-3))==\':ne\') {\\n        $k = substr($k,0,-3).\':!=\';\\n    }\\n    elseif (strtolower(substr($k,-3))==\':gt\') {\\n        $k = substr($k,0,-3).\':>\';\\n    }\\n    elseif (strtolower(substr($k,-4))==\':gte\') {\\n        $k = substr($k,0,-4).\':>=\';\\n    }\\n    elseif (strtolower(substr($k,-3))==\':lt\') {\\n        $k = substr($k,0,-3).\':<\';\\n    }\\n    elseif (strtolower(substr($k,-4))==\':lte\') {\\n        $k = substr($k,0,-4).\':<=\';\\n    }\\n    elseif (strtolower(substr($k,-5))==\':like\') {\\n        $v = \'%\'.trim($v,\'%\').\'%\';\\n    }\\n    elseif (strtolower(substr($k,-9))==\':not_like\') {\\n        $k = substr($k,0,-9).\':NOT LIKE\';\\n        $v = \'%\'.trim($v,\'%\').\'%\';\\n    }\\n    elseif (strtolower(substr($k,-3))==\':in\') {\\n        $v = (!is_array($v))? explode(\',\',$v):$v;\\n        $v = array_map(\'trim\', $v);\\n    }\\n    elseif (strtolower(substr($k,-7))==\':not_in\') {\\n        $k = substr($k,0,-7).\':NOT IN\';\\n        $v = (!is_array($v))? explode(\',\',$v):$v;\\n        $v = array_map(\'trim\', $v);\\n    }\\n    elseif (strtolower(substr($k,-12))==\':starts_with\') {\\n        $k = substr($k,0,-12).\':LIKE\';\\n        $v = trim($v,\'%\').\'%\';\\n    }\\n    elseif (strtolower(substr($k,-10))==\':ends_with\') {\\n        $k = substr($k,0,-10).\':LIKE\';\\n        $v = \'%\'.trim($v,\'%\');\\n    }\\n\\n    if (strtolower($v) == \'null\') {\\n        $v = null;\\n    }\\n\\n    \\/\\/ Manually set an operator\\n    if (isset($scriptProperties[\'_op_\'.$k])) {\\n        $k = $k.\':\'.ltrim($scriptProperties[\'_op_\'.$k],\':\');\\n    }\\n    unset($scriptProperties[\'_op_\'.$k]);\\n\\n    \\/\\/ Does the column belong to the site_content table? Or does it represent a TV?\\n    if (strpos($k, \':\') !== false)\\n    {\\n        $tmp = explode(\':\', $k);\\n        if (count($tmp) == 2)\\n        {\\n            $column_name = $tmp[0];\\n        }\\n        else\\n        {\\n            $column_name = $tmp[1];\\n        }\\n    }\\n    else\\n    {\\n        $column_name = $k;\\n    }\\n\\n    if (in_array($column_name, $page_cols))\\n    {\\n        $filters[$k] = $v;\\n    }\\n    else\\n    {\\n        $k = str_replace($column_name,\'value\',$k);\\n        $tvfilters[] = array(\\n            \'tvname\' => $column_name,\\n            \'filter\' => $k,\\n            \'value\' => $v\\n        );\\n    }\\n}\\n\\n\\/\\/ Read the control arguments\\n$tpl = $modx->getOption(\'_tpl\', $control_params);\\n$tplOuter = $modx->getOption(\'_tplOuter\', $control_params);\\n$view = $modx->getOption(\'_view\', $control_params,\'table\');\\n$limit = (int) $modx->getOption(\'_limit\', $control_params);\\n$sortby = $modx->getOption(\'_sortby\', $control_params);\\n$sortdir = $modx->getOption(\'_sortdir\', $control_params,\'ASC\');\\n$page = (int) $modx->getOption(\'_page\', $control_params);\\n$offset = (int) $modx->getOption(\'_offset\', $control_params);\\n$sql = $modx->getOption(\'_sql\', $control_params);\\n$style = $modx->getOption(\'_style\', $control_params, \'default\');\\n$select = $modx->getOption(\'_select\', $control_params,\'*\');\\n$log_level = (int) $modx->getOption(\'_log_level\', $control_params,$modx->getOption(\'log_level\'));\\n$config = basename($modx->getOption(\'_config\', $control_params,\'default\'),\'.config.php\');\\n$debug = (int) $modx->getOption(\'_debug\', $control_params);\\n$rename = $modx->getOption(\'_rename\', $control_params);\\n\\nif ($rename && !is_array($rename))\\n{\\n    $rename = json_decode($rename,true);\\n    if(!is_array($rename))\\n    {\\n        $modx->log(xPDO::LOG_LEVEL_DEBUG,\'[queryResources] _map input must be a valid JSON hash\');\\n    }\\n}\\n\\n\\n$old_log_level = $modx->setLogLevel($log_level);\\n\\n\\/\\/ Get page ids from primary query (if filters are present)\\n$intersects = array();\\nif ($filters)\\n{\\n    $criteria = $modx->newQuery(\'modResource\');\\n    $criteria->select(\'id\');\\n    $criteria->where($filters);\\n\\n    if ($results = $modx->getIterator(\'modResource\',$criteria))\\n    {\\n        $this_set = array();\\n        foreach ($results as $r)\\n        {\\n            $this_set[] = $r->get(\'id\');\\n        }\\n        $intersects[] = $this_set;\\n    }\\n}\\n\\nif ($tvfilters)\\n{\\n    foreach($tvfilters as $tf)\\n    {\\n        if (empty($tf[\'value\'])) continue;\\n        \\n        $criteria = $modx->newQuery(\'modTemplateVarResource\');\\n        $criteria->select(\'contentid\');\\n        $this_filter = array(\\n            \'tmplvarid\' => $tvlookup_by_name[$tf[\'tvname\']],\\n            $tf[\'filter\'] => $tf[\'value\']\\n        );\\n\\n        $criteria->where($this_filter);\\n        if ($results = $modx->getIterator(\'modTemplateVarResource\',$criteria))\\n        {\\n            $this_set = array();\\n            foreach ($results as $r)\\n            {\\n                $this_set[] = $r->get(\'contentid\');\\n            }\\n            $intersects[] = $this_set;\\n        }\\n    }\\n}\\n\\n\\nif (count($intersects) > 1)\\n{\\n    $intersects = call_user_func_array(\'array_intersect\', $intersects);\\n}\\nelse\\n{\\n    $intersects = array_shift($intersects);\\n}\\n\\/\\/ Page ids here!\\n$intersects = array_values($intersects);\\n$record_count = count($intersects);\\nif ($debug) {\\n    return \'<div><h2><code>queryResources<\\/code> Snippet Debug<\\/h2><h3>Primary Filters<\\/h3><textarea rows=\\"10\\" cols=\\"60\\">\'.print_r($filters,true).\'<\\/textarea>\\n        <h3>TV Filters<\\/h3>\\n        <textarea rows=\\"10\\" cols=\\"60\\">\'.print_r($tvfilters,true).\'<\\/textarea>\\n        <h3>Matching Page IDs<\\/h3>\\n        <textarea rows=\\"10\\" cols=\\"60\\">\'.print_r($intersects,true).\'<\\/textarea>\\n    <\\/div>\';\\n}\\n\\n$real_cols = array(); \\/\\/ real columns in modx_site_content\\n$virtual_cols = array(); \\/\\/ virtual columns are TVs\\nif ($select != \'*\') {\\n    $cols = explode(\',\',$select);\\n    $cols = array_map(\'trim\', $cols);\\n    $virtual_cols = array_diff($cols, $page_cols);\\n    $real_cols = array_intersect($page_cols, $cols);\\n    if (!in_array(\'id\', $real_cols))\\n    {\\n        $real_cols[] = \'id\'; \\/\\/ make sure we have the pk\\n    }\\n}\\n\\n\\n\\n$data = array();\\n$tvdata = array();\\n\\n\\n\\/*\\n * Load up TVs ONLY when needed (i.e. if virtual columns were specified)\\n * Format should be:\\n * array(\\n *  [page_id] => array(\\n *      [tv-name] => tv-value\\n *      [other-tv-name] => other value\\n *   ),\\n *   \\/\\/ ...etc...\\n * )\\n *\\/\\nif ($virtual_cols || $select == \'*\') {\\n    $criteria = $modx->newQuery(\'modTemplateVarResource\');\\n\\n\\/\\/ Get \'em all\\n    if (empty($virtual_cols) && $select == \'*\') {\\n        $this_filter = array(\\n            \'contentid:IN\' => $intersects,\\n        );\\n    } \\/\\/ Only get the ones specified\\n    else {\\n        $virtual_col_ids = array();\\n        foreach ($virtual_cols as $vc) {\\n            $virtual_col_ids[] = $tvlookup_by_name[$vc];\\n        }\\n        $this_filter = array(\\n            \'contentid:IN\' => $intersects,\\n            \'tmplvarid:IN\' => $virtual_col_ids\\n        );\\n    }\\n\\n    $criteria->where($this_filter);\\n\\n    if ($results = $modx->getIterator(\'modTemplateVarResource\', $criteria)) {\\n        \\/\\/return $criteria->toSQL();\\n        foreach ($results as $r) {\\n            $tvdata[$r->get(\'contentid\')][$tvlookup_by_id[$r->get(\'tmplvarid\')]] = $r->get(\'value\');\\n        }\\n    }\\n}\\n\\/\\/ Load up the base pages\\n$criteria = $modx->newQuery(\'modResource\');\\n$criteria->select($real_cols); \\/\\/ Only the built-in columns here\\n$criteria->where(array(\'id:IN\'=>$intersects));\\n\\n$criteria->limit($limit, $offset);\\nif ($sortby)\\n{\\n    $criteria->sortby($sortby,$sortdir);\\n}\\n\\n\\n\\/\\/ Load up pages\\nif($results = $modx->getIterator(\'modResource\',$criteria))\\n{\\n    foreach ($results as $r) {\\n        $this_row = $r->toArray(\'\',false,true);\\n        if (isset($tvdata[ $r->get(\'id\') ]))\\n        {\\n            $this_row = array_merge($this_row, $tvdata[ $r->get(\'id\') ]);\\n        }\\n        \\/\\/ Map...\\n        if ($rename)\\n        {\\n            foreach ($rename as $old => $new)\\n            {\\n                if (isset($this_row[$old]))\\n                {\\n                   $this_row[$new] = $this_row[$old];\\n                   unset($this_row[$old]);\\n                }\\n            }\\n        }\\n        $data[] = $this_row;\\n    }\\n}\\nif (empty($data)) {\\n    $modx->log(xPDO::LOG_LEVEL_DEBUG,\'[queryResources] No output.\');\\n    return \'\';\\n}\\n\\n$out = \'\';\\n$pagination_links = \'\';\\n\\n\\/\\/ Pagination\\nif ($limit && $record_count > $limit) {\\n\\n    $pagination_links = Pagination\\\\Pager::links($record_count, $offset, $limit)\\n        ->setBaseUrl($modx->makeUrl($modx->resource->get(\'id\'),\'\',\'\',\'abs\'))\\n        ->style($style);\\n    $page_count = ceil(record_count \\/ $limit);\\n}\\n\\n\\/\\/ Default formatting (via a PHP view)\\nif (!$tpl && !$tplOuter) {\\n    $view_file = $core_path.\'views\\/\'.basename($view,\'.php\').\'.php\';\\n    if (!file_exists($view_file)) {\\n        $view_file = $view;\\n        if (!file_exists($view_file)) {\\n            $modx->log(xPDO::LOG_LEVEL_ERROR,\'[Query] The view file \'.$view_file.\' does not exist.\');\\n            return \'The view file \'.htmlspecialchars($view_file).\' does not exist.\';\\n        }\\n    }\\n    ob_start();\\n    include $view_file;\\n    $out = ob_get_contents();\\n    ob_end_clean();\\n}\\nelseif($tpl)\\n{\\n\\n    $use_tmp_chunk = false;\\n    if (!$innerChunk = $modx->getObject(\'modChunk\', array(\'name\' => $tpl))) {\\n        $use_tmp_chunk = true; \\/\\/ No chunk was passed... a formatting string was passed instead.\\n    }\\n\\n    foreach ($data as $r) {\\n        if (is_object($r)) $r = $r->toArray(\'\',false,false,true); \\/\\/ Handle xPDO objects\\n        \\/\\/ Use a temporary Chunk when dealing with raw formatting strings\\n        if ($use_tmp_chunk) {\\n            $uniqid = uniqid();\\n            $innerChunk = $modx->newObject(\'modChunk\', array(\'name\' => \\"{tmp-inner}-{$uniqid}\\"));\\n            $innerChunk->setCacheable(false);\\n            $out .= $innerChunk->process($r, $tpl);\\n        }\\n        \\/\\/ Use getChunk when a chunk name was passed\\n        else {\\n            $out .= $modx->getChunk($tpl, $r);\\n        }\\n    }\\n}\\n\\nif ($tplOuter) {\\n    $props = array(\'content\'=>$out);\\n    \\/\\/ Formatting String\\n    if (!$outerChunk = $modx->getObject(\'modChunk\', array(\'name\' => $tplOuter))) {\\n        $uniqid = uniqid();\\n        $outerChunk = $modx->newObject(\'modChunk\', array(\'name\' => \\"{tmp-outer}-{$uniqid}\\"));\\n        $outerChunk->setCacheable(false);\\n        $out = $outerChunk->process($props, $tplOuter);\\n    }\\n    \\/\\/ Chunk Name\\n    else {\\n        $out = $modx->getChunk($tplOuter, $props);\\n    }\\n}\\n\\n\\/\\/ Set placeholders\\n$modx->setPlaceholder(\'page_count\',$page_count);\\n$modx->setPlaceholder(\'results\',$out);\\n$modx->setPlaceholder(\'pagination_links\',$pagination_links);\\n$modx->setLogLevel($old_log_level);\\n\\n$results = array(\\n    \'page_count\' => $page_count,\\n    \'results\' => $out,\\n    \'pagination_links\' => $pagination_links,\\n);\\n\\n\\/\\/ Cache the lookup\\n$modx->cacheManager->set($fingerprint, $results, $lifetime, $cache_opts);\\n\\nreturn $out;"}',
        'guid' => 'b56ce33979335a84d1411aeb006ff880',
        'native_key' => 2,
        'signature' => '1318e33566a970fa1e2d9cdd1c19d83b',
      ),
    ),
    'Plugins' => 
    array (
      '92cbbc5b4d630cc0bb5e0025d4e952b3' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'related_object_attributes' => 
        array (
          'PluginEvents' => 
          array (
            'preserve_keys' => true,
            'update_object' => false,
            'unique_key' => 
            array (
              0 => 'pluginid',
              1 => 'event',
            ),
          ),
        ),
        'class' => 'modPlugin',
        'object' => '{"id":1,"source":0,"property_preprocess":0,"name":"QueryCacheClean","description":"Remove results cached by the Query and queryResource Snippets.","editor_type":0,"category":0,"cache_type":0,"plugincode":"\\/**\\n * @name QueryCacheClean\\n * @description Remove results cached by the Query and queryResource Snippets.\\n * @PluginEvents OnBeforeCacheUpdate\\n *\\/\\n\\n$cache_dir = \'query\';\\nswitch ($modx->event->name) {\\n\\n    \\/\\/------------------------------------------------------------------------------\\n    \\/\\/! OnBeforeCacheUpdate\\n    \\/\\/  Clear out our custom cache files.\\n    \\/\\/------------------------------------------------------------------------------\\n    case \'OnBeforeCacheUpdate\':\\n        $modx->log(modX::LOG_LEVEL_DEBUG,\'[QueryCacheClean plugin] \',\'OnBeforeCacheUpdate\');\\n        $modx->cacheManager->clean(array(xPDO::OPT_CACHE_KEY => $cache_dir));\\n        break;\\n}\\n\\/*EOF*\\/","locked":0,"properties":null,"disabled":0,"moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * @name QueryCacheClean\\n * @description Remove results cached by the Query and queryResource Snippets.\\n * @PluginEvents OnBeforeCacheUpdate\\n *\\/\\n\\n$cache_dir = \'query\';\\nswitch ($modx->event->name) {\\n\\n    \\/\\/------------------------------------------------------------------------------\\n    \\/\\/! OnBeforeCacheUpdate\\n    \\/\\/  Clear out our custom cache files.\\n    \\/\\/------------------------------------------------------------------------------\\n    case \'OnBeforeCacheUpdate\':\\n        $modx->log(modX::LOG_LEVEL_DEBUG,\'[QueryCacheClean plugin] \',\'OnBeforeCacheUpdate\');\\n        $modx->cacheManager->clean(array(xPDO::OPT_CACHE_KEY => $cache_dir));\\n        break;\\n}\\n\\/*EOF*\\/","PluginEvents":"OnBeforeCacheUpdate"}',
        'guid' => 'f8da6b65368782d4bc7b14986f82b778',
        'native_key' => 1,
        'signature' => 'd741aef10ce97c0db7be136dcefc591e',
        'related_objects' => 
        array (
          'PluginEvents' => 
          array (
            'af1b03f9b718a58204e8de3fd769fe07' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnBeforeCacheUpdate","priority":0,"propertyset":0}',
              'guid' => '10dd54995a9e671804895f36eedf3ce9',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnBeforeCacheUpdate',
              ),
              'signature' => '1e5cb4eb6c53026195fbf4329cbd9406',
            ),
          ),
        ),
      ),
    ),
  ),
  'related_object_attributes' => 
  array (
    'Snippets' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'Chunks' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'Plugins' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
      'related_object_attributes' => 
      array (
        'PluginEvents' => 
        array (
          'preserve_keys' => true,
          'update_object' => false,
          'unique_key' => 
          array (
            0 => 'pluginid',
            1 => 'event',
          ),
        ),
      ),
    ),
    'modTemplate' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'templatename',
    ),
    'modTemplateVar' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
  ),
  'namespace' => 'query',
  'resolve' => 
  array (
    0 => 
    array (
      'type' => 'file',
      'body' => '{"source":"query-1.3.1-pl\\/modCategory\\/fa82dd6b269e424d48d55ecfc2bc9a33\\/0\\/","target":"return MODX_CORE_PATH . \'components\\/\';","name":"query"}',
    ),
  ),
  'validate' => NULL,
  'vehicle_package' => 'transport',
  'vehicle_class' => 'xPDOObjectVehicle',
  'guid' => 'ce9252adce08f40ee5c1fc731e1b82e7',
  'package' => 'modx',
  'class' => 'modCategory',
  'signature' => 'fa82dd6b269e424d48d55ecfc2bc9a33',
  'native_key' => NULL,
  'object' => '{"id":null,"parent":0,"category":"Query"}',
);